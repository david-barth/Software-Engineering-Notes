Hibernate + JPA Practical Notes 1: Setting up ORM for Nested / Complex Objects. 


Basics to Hibernate Model <-> DB Interactions: 

---> A model is a POJO that is what a database table is mapped onto in the process of ORM. 

---> The minimum that a model object needs is identified as follows: 


	@Entity 
	@Table(name = "tableName")
	public class User {
	
		@Id 
		@GeneratedValue(strategy = GenerationType.IDENTITY)
		@Column(name = "user_id")
		private int userID; 


		@Column(name = "name")
		private String name; 
	}	

	---> @Entity marks the POJO as being an object that corresponds with a row of a table in a database. 

	---> @Table can be used to explicitly define the table which corresponds with the object. 

	---> @Entity vs @Table: 

		---> One difference is that @Entity marks the name of an entity in a table.  Often table names are different than the entities which poppulate the table.          

			---> E.g. Student (entity) vs Students (Table)

			---> @Entity is used to officially mark the name of the entity, but if @Table is not used then the class name of the model is considered the default table name by Hibernate.     

			---> If @Table is used, then the official difference between the entity and table names can be formalized.  Hibernate will use the @Entity name (or class name if @Entity is empty) as the database entity name while using the table name as the table name. 


		---> Another difference is that @Table contains some arguments that can be used for purposes relating to things such as table schema. 


	---> @Id is used to mark the primary key of the table.  

	---> @Column is used to mark explicitly mark the name of the column to which a field of the model corresponds to. 

		---> The default is the field name, but this is overcome by specifyin a name as an argument to the annotation. 


	---> @GeneratedValue() is used to define auto-generated values. 
		
		---> In a relational DB, there are several ways to auto-generate values, which is accounted for by the Strategy design pattern used as a component for this annotation. 

		---> In the above example, the strategy / algorithm corresponds with auto-incrementing. 


---> The above counts for a simple model <-> table mapping.  What follows is the style needed for more complex mappings consisting of nested objects to hierarchal table structures. 



Defining a relationship between entities: 

---> Internally this is accomplished by using joins and foreign keys to help define the mappings that occur in relationships between database entities. 


---> In SQL, there are 2 sides to the relationship: 

	A. The owner => This is the entity posessing the foreign key. 

	B. The child / referee => This is the entity being referenced by the foreign key. 


---> In the next level of the relationship, there is also a sense of directionality: 

	A. Unidirectional => Only one entity has a property that refers to the other entity. 

		---> This occurs with when the owning entity is the only one that has a foreign key referencing the other entity in the relationship.  


	B. Bidirectiinal => Both entities have a referencing field to the other.  

		---> This occurs in a few ways: 

			A. Each entity has a foreign key to the other. 

			B. There is a "join table" that encapsulates both the foreign keys of the entities in a separate table.  



---> This conceptual schematic translates as follows in Hibernate: 


	A. @JoinColumn(name = "FK_ID") => This annotation specifies the foreign key that is used as a join point on the OWNING entity of the relationship. 

		---> This defines a unidirectional mapping to the owning side. 

		---> Note: @JoinColumn will replace @Column as the annotation to define the nested object as a column. 

			---> This annotation targets the actual foreign key column in the owning entity and is literally a column that "joins" to another column. 
		
		---> Note that Hibernate will generate a foreign key column use a SQL notation for table names such as contributor_group_id. 

			---> _ is placed in between each word when mapping from camelcase to SQL notation. 

 

	B. @OneToMany(..., mappedBy = "someEntity") => The property of "mappedBy" specifies the name of the field on the owning side that corresponds with the entity that is being referenced to. 

		---> In a direct relationship, this will define a bidirectional relationship between the 2 entities. 


	---> However, in the case of a join table, only @JoinColumn needs to be used because the presence of a join table implies an indirect bi-directional table between two entities, with the join table as an intermediary. 



Entity Manager: Persisting Objects with the Entity Manager. 

---> The EntityManager is a wrapper around the Hibernate session object and therefore takes on the role of session when managing transactions to the database. 

	---> EntityManager is defined in line with the JPA standard, while Hibernate's Session object is a specific implementation to Hibernate. 

	---> EntityManager is effectively the "interface" that is implemented by the Hibernate Session class. 

	---> The same things can be said about the Factory classes that correspond to the 2 types of objects. 


---> Assuming Hibernate is being used as the JPA implementation, EntityManager will actually be Session effectively. 

	---> But other implementations of JPA can be used over Hibernate and EntityManager will therefore have Session swapped out for a similar transaction management class. 


---> The similarity in these 2 classes (EntityManager vs Session) can be seen in their configuration files in that they account for various data source properties such the JDBC connection,  connectors to the data source, etc. 


Setting up Relatonships: Example For one-to-many relationships. 


---> An example shows how this is done for a uni-directional relationship: 

	@Entity
	@Table(name = "A")
	public class A {
		
		@OneToMany
		@JoinColumn(name = "A_id")
		private List<B> BCollection; 	
	}


	@Entity
	@Table(name = "B") 
	public class B {

		...
	}

	---> In a uni-directional relationship, only the @OneToMany annotation needs to be added to point to the parent class over the collection of children objects. 

		---> Reminder: @OneToMany, @ManyToMany, etc all act as pointers to the fields that they annotate.  

		---> The @JoinColumn will also be placed on the parent class, with the "name" argument referring to the foreign key on the child class / table. 

			---> Note: Hibernate will transform the name supplied from CamelCase to a SQL table notation (e.g. camel_case). 

			---> Therefore, foreign key names must be done in SQL notation in order to avoid having a default column created. 


	

---> The next example focuses on a bi-directional one-to-many relationship: 

	@Entity 
	@Table(name = "A") 
	public class A {

		@OneToMany(mappedBy = "entityA)
		private List<B> BCollection; 
	}


	@Entity
	@Table(name = "B")
	public class B {
		@ManyToOne
		@JoinColumn(name = "a_id")
		private A entityA; 
	}
	

	---> In this case, @JoinColumn is placed onto the child class field reference to the parent class (ie on A). 

		---> A @ManyToOne mapping is specified for the child class and acts as a backward reference to the parent class. 

	---> The @OneToMany annotation has the mappedBy argument which is used to specify the connection to the child class by mapping the parent class to its respective field on the child class. 

	---> IMPORTANT: The parent -> child association is automatically present during the mapping process of JPA / Hibernate, but the child -> Parent association needs to be manually set either via a helper method or similar code within the Repository / DAO.   

		---> Example: 

		entityB.set(EntityA); 
		entityManager.persist(entityA);

		---> The above code applies to one-to-one relationships, but a looped version applies to setting the parent to the children of the one-to-many variation. 

		---> This must be done before persisting the relationship + committing, otherwise the foreign key of the child table records will be null since the parent was not set to the child. 


	---> Note: For data that is serialized / deserialized by Jackson, an infinite recursion will occur when trying to persist the relationship. 



Extra: The Sequence of events for Hibernate. 

---> This section focuses on a brief examination of the 2 stage process that occurs from Hibernate to the database. 

	---> For further notes on the complete version of the Hibernate entity lifecycle, see the relevant theory notes. 


---> Hibernate processing occurs in 2 stages: 

	1. Persistence Context => When application code calls upon the persistence context object (e.g. EntityManager or Session), the composite objects and their relationships are taken into the context. 

		---> Inside of the context, the relationships are taken as a snapshot, which forms the basis for the mapping. 

		---> Therefore, objects that are set to each other are taken as the in-memory form of the table relationships in the database. 

	
	2. Mapping to the database => The persistence code will then do in-memory operations necessary in order to prepare the objects and their relationships for mapping into the database. 

		---> When the necessary data structures (e.g. a tree) is formed, then the "snapshot" is translated into SQL statements. 



Extra 2: Dealing with JSON derived Data for Advanced Relationship Mappings. 

---> As referenced above, this deals with the infinite recursion issue that occurs for data that has been deserialized by Jackson, when it is being mapped by Hibenate to the database. 

---> The situation is remedied by adding 2 annotations from the Jackson library to the entities:


	@Entity 
	@Table(name = "A") 
	public class A {

		@OneToMany(mappedBy = "entityA)
		@JsonManagedReference
		private List<B> BCollection; 
	}


	@Entity
	@Table(name = "B")
	public class B {
		@ManyToOne
		@JoinColumn(name = "a_id")
		@JsonBackReference
		private A entityA; 
	}

	---> In bi-directional relationships, Jackson will encounter an issue of cyclic dependence in the serialization of the 2 objects. 

	---> Jackson will attempt to serialize Entity A and then use the reference to Entity B to go to B and serialize it. 

	---> After serializing B, Jackson will then go back to serialize A.  This cyclic process of serialization will occur repeatedly until a stack overflow occurs, using up the available memory due to an infinite recursion. 

	---> This is solved via the use of the @JsonManagedReference and @JsonBackReference annotations, which do the following: 


		A. @JsonManagedReference => This tells the annotated field (ie the forward reference) to be serialized during a process called Marshalling. 

		B. @JsonBackReference => This tells the annotated field (ie the back reference) to be left unserialized and the relationship will be reconstructed during the unmarshalling / deserialization process of the forward reference. 



Extra 3: Persisting a composite entity with multiple levels of nesting using Eager fetching.  

---> A composite entity that has multiple one-to-many / many-to-many relationships contain nested components that each use Lists as a type. 

---> An issue arises when multiple lists, with eager fetching defined, occurs: 

	---> Note: A list type forming a "many" part of a relationship is referred to as a bag. 

	---> Therefore, an exception called "MultipleBagFetchException" occurs.  

	---> Each @OneToMany, @OneToOne, etc relationship annotations corresponds to a join operation (likely a left outer join). 

		---> Multiple left joins produce an overall result that contains duplicate entries, which would produce anomalous results. 

		---> The origin of the issue occurs because the left joins produce a cartesian product (ie a multiplication of a list of values with another list of values). 

			---> The result is a set of records / combination of values, which represent all possible combinations of values. 

			---> Practical result => Duplicate / redundant records are generated from the left join operations. 

		---> To remove the records, deduplication of the redundant records must occur, taking up considerable resources and ultimately giving performance issues. 

		---> This is why Hibernate prevents Lists (ie unordered collections) from being used in this manner by throwing an exception. 

	---> Relationship to eager fetching: Eager fetching produces underlying join operations on data which has already been fetched previously.

		---> The ultimate result is data which is effectively joined onto itself in some way producing a redundant result.  


---> A surface fix is to change the List interface for the field entry to a Set interface. 

	---> Rationale => Lists represent unordered collections that can contain duplicates. 

		---> Under the hood, Hibernate will perform operations using Lists that are corresponding to a join, which will produce the duplicate results mentioned above. 


	---> A set is a collection that only has distinct values to it, eliminating the duplicate results from the returned resulting data collection. 

	---> This surface issue still does not eliminate the cartesian product issue. 

		---> Ie the redundancy will still cause unnecessary resource consumption and performance issues. 


---> A real fix to this concentrates on limiting the data fetching to their respective collections rather than redundantly having the fetches occur, as the eager case would involve. 

	---> One concrete solution to this is using independent selects with eager fetching enabled for each bag / collection based field. 

	---> An example is shown: 

 	@OneToMany(mappedBy = "doctor", fetch = FetchType.EAGER)
    	@org.hibernate.annotations.Fetch(FetchMode.SELECT)
    	private Set appointments;

    	@OneToMany(mappedBy = "leadingDoctor", fetch = FetchType.EAGER)
    	@org.hibernate.annotations.Fetch(FetchMode.SELECT)
    	private Set patients;

	---> This example applies purely for Hibernate and involves using an annotation to add granularity to the fetch method by telling it to use independent selects from each other. 

	---> End Result => This isolates the fetching to one SQL query per associated collection. 


---> This problem is one important reason why lazy fetching is encouraged over eager fetching: 

	---> Lazy fetching involves "on-demand" data loading, which means one retrieval occurs per demand. 

	---> Lazy fetching naturally resolves the issue stated above. 


---> Another possibility to solve this problem is to specify individual queries to isolate the fetching to one distinct fetch per collection.  

---> For persisting objects initially, a fetch will not be performed as there is no data to load from the data source for a new record. 

	---> But Hibernate still throws the exception when it encounters a composite entity that consists of "multiple bags" / non-set collections. 
 




	 	