Hibernate + JPA Practical Notes 1: Setting up ORM for Nested / Complex Objects. 


Basics to Hibernate Model <-> DB Interactions: 

---> A model is a POJO that is what a database table is mapped onto in the process of ORM. 

---> The minimum that a model object needs is identified as follows: 


	@Entity 
	@Table(name = "tableName")
	public class User {
	
		@Id 
		@GeneratedValue(strategy = GenerationType.IDENTITY)
		@Column(name = "user_id")
		private int userID; 


		@Column(name = "name")
		private String name; 
	}	

	---> @Entity marks the POJO as being an object that corresponds with a row of a table in a database. 

	---> @Table can be used to explicitly define the table which corresponds with the object. 

	---> @Entity vs @Table: 

		---> One difference is that @Entity marks the name of an entity in a table.  Often table names are different than the entities which poppulate the table.          

			---> E.g. Student (entity) vs Students (Table)

			---> @Entity is used to officially mark the name of the entity, but if @Table is not used then the class name of the model is considered the default table name by Hibernate.     

			---> If @Table is used, then the official difference between the entity and table names can be formalized.  Hibernate will use the @Entity name (or class name if @Entity is empty) as the database entity name while using the table name as the table name. 


		---> Another difference is that @Table contains some arguments that can be used for purposes relating to things such as table schema. 


	---> @Id is used to mark the primary key of the table.  

	---> @Column is used to mark explicitly mark the name of the column to which a field of the model corresponds to. 

		---> The default is the field name, but this is overcome by specifyin a name as an argument to the annotation. 


	---> @GeneratedValue() is used to define auto-generated values. 
		
		---> In a relational DB, there are several ways to auto-generate values, which is accounted for by the Strategy design pattern used as a component for this annotation. 

		---> In the above example, the strategy / algorithm corresponds with auto-incrementing. 


---> The above counts for a simple model <-> table mapping.  What follows is the style needed for more complex mappings consisting of nested objects to hierarchal table structures. 



Defining a relationship between entities: 

---> Internally this is accomplished by using joins and foreign keys to help define the mappings that occur in relationships between database entities. 


---> In SQL, there are 2 sides to the relationship: 

	A. The owner => This is the entity posessing the foreign key. 

	B. The child / referee => This is the entity being referenced by the foreign key. 


---> In the next level of the relationship, there is also a sense of directionality: 

	A. Unidirectional => Only one entity has a property that refers to the other entity. 

		---> This occurs with when the owning entity is the only one that has a foreign key referencing the other entity in the relationship.  


	B. Bidirectiinal => Both entities have a referencing field to the other.  

		---> This occurs in a few ways: 

			A. Each entity has a foreign key to the other. 

			B. There is a "join table" that encapsulates both the foreign keys of the entities in a separate table.  



---> This conceptual schematic translates as follows in Hibernate: 


	A. @JoinColumn(name = "FK_ID") => This annotation specifies the foreign key that is used as a join point on the OWNING entity of the relationship. 

		---> This defines a unidirectional mapping to the owning side. 

		---> Note: @JoinColumn will replace @Column as the annotation to define the nested object as a column. 

			---> This annotation targets the actual foreign key column in the owning entity and is literally a column that "joins" to another column. 
		
 

	B. @OneToMany(..., mappedBy = "someEntity") => The property of "mappedBy" specifies the name of the field on the owning side that corresponds with the entity that is being referenced to. 

		---> In a direct relationship, this will define a bidirectional relationship between the 2 entities. 


	---> However, in the case of a join table, only @JoinColumn needs to be used because the presence of a join table implies an indirect bi-directional table between two entities, with the join table as an intermediary. 







	