Advanced Mapping Concepts: Hibernate (with SQL notes where necessary) 


Introduction to Advanced Mappings in Hibernate: 

---> Advanced mappings cover the cases of multiple tables in a database having relationships between each other. 

---> Reminder: Relationships are usually defined via the use of a foreign key (e.g. a primary key of a table) being present in another table. 

	---> The foreign key refers to the partner table and is therefore what binds tables together in a logical relationship. 


---> There are many different ways to consider the relationship including complex usages like relationship directionality, but the 4 main relationships here are: 


	A. One-to-One

	B. One-to-Many

	C. Many-to-One

	D. Many-to-Many

	---> Each can have different usages of foreign keys.  

	---> Important: A-C are effectively tree data structures while Many-to-Many is a graph data structure. 


Reinforcement of Database Concepts: 

---> Basic notes on the use cases of foreign keys and primary keys can be found in the SQL notes. 

---> Here the focus is on cascading, which is a term describing the same operation being applied to the same entities. 

	---> Ie if an entity A is updated and a cascade exists between A and B, then entity B will also be saved.  

	---> This is also equally the case for deleting entities in a relationship too, but the use case for deletion cascades must be carefully considered. 


---> Another concept that is considered is loading: 

	---> This determines whether all data related to an entity is retrieved all at once or on request: 
	
	---> There are 2 types of loading: 

		A. Eager loading => This type of loading retrieves every entity that is associated with an entity being retrieved. 

			---> This type of loading has performance implications due to the volume of data that is retrieved, especially in the case many-to-many relationships. 

	
		B. Lazy loading => This type of loading retrieves related entities only on request.  

			---> Lazy loading is more efficient performance wise for applications. 


---> Directionality is also a consideration between 2 entities: 

	A. Uni-directional => This implies a one way relationship between entities A and B in which entity A can access entity B, but not the other way around. 

	B. Bi-directional => This implies a two way relationship between entities A and B in which either entity can access the other via references. 



One-to-One Relationships in Hibernate: 

---> A foreign key relationship is meant to do 2 things: 

	A. Link tables together into a relationship. 

	B. Allow parent-child tables to be joined together in join operations for queries. 

	C. Maintain referential integrity between the 2 tables. 

	---> In other words, 2 tables linked together by a foreign key are protected from operations that would destroy that relationship. 

	---> Only valid data is inserted into the foreign key column, which is usually the primary key of the other table (ie parent table). 


---> In Hibernate, an entity also has a life cycle that is similar to a bean.  There are 5 operations associated with the entity lifecycle: 

	A. Detach => Allows an entity to be detached or dissociated from a Hibernate session. 

	B. Merge => Assoicates a detached entity to a session. 

	C. Persist => This transitions entities to a managed state, which allows the entity to be saved in the DB on the net flush / commit. 

	D. Remove => Transitions a managed entity to be removed such that the next flush / commit will delete the entity from the DB. 

	E. Refresh => Reloads / Resynchronizes data the entity with data from the DB preventing stale data. 


	---> Each of these operations also corresponds with a CRUD method that is associated with the EntityManager of the JPA specification. 

	---> Note: "Flushing" means to synchronize the temporary state of application data with the permanent state of data from a database or hard disk. 

		---> This is almost the inverse of committing in which application data is used to update the state of corresponding data in the datanase. 


	---> In the Hibernate entity lifecycle, there is an implicit set of states and thus locations for an entity: 


		A. Client Code (Application Code) => The application business layer is the "client" code that makes use of the API provided by the persistence context in order to interact with the database. 

			---> Here is where entities in a "detached" state occur and detached entities are not tracked by the persistence context. 

			---> Detached entities can be merged to the persistence context in order to become a managed entity. 

				---> The detached entity is simply a POJO that has an identity value corresponding to a database row. 

				---> The Id is all that is necessary in order to allow the persistence context to connect the detached entity to its corresponding data in the database. 


			---> Transient entities are also found in the application / client code, but have no Id corresponding to an identity in a database record. 

				---> These are simply objects that have been created in application code (e.g. as DTOs), which could be made persistent via persistence context methods.  




		B. Persistence Context => This is a staging area where persistent data and entities are interconverted amongst each other during transactions. 

			---> This is an implementation of the Unit of Work design pattern and is similar in concept to the git staging area. 

			---> Here, changes to the data are tracked and these changes are synchronized to the database at the end of a transaction. 

			---> EntityManager and Session are implementations of the persistence context. 

			---> All entities that are managed by the persistence context are "merged" with it, as described above. 

				---> Therefore, merged entities have changes tracked.  

			---> In this sense, the persistence context acts as a container for entities in a similar way as the Spring Container / context does for beans. 
 
			---> Managed entities are always persistent in that each has a database identifier, even if it doesn't exist in the database just yet. 

			---> An entity that has a "deleted" state is marked for deletion and therefore removal from the DB via the persistence context.  

				---> The deleted state entities are still attached to the persistence context.    


		C. Data Store => This is where the persistent data is found and the ORM interacts with this layer.  


---> Additional note: A transaction is called a "unit of work" and here both client code + SQL operations can be performed in the overall application architecture. 

	---> This work includes any persistence context operations 

	---> When a transaction is opened, all code execution in that period of time is devoted to the interaction of database with the persistence context and the client code.

	---> There are 2 conclusions of a transaction: 

		A. Commit => Used to save changes of a current transaction in a permanent way. 

		B. Rollback => Used to undo changes made on the curren transaction. 

	

--->  The following example uses 2 classes and 2 tables: Instructor + Instructor_detail (InstructorDetail in entity form)


	@Entity
	@Table(name = "instructor")
	public class Instructor {

		@OneToOne
		@JoinColumn(name="instructor_detail_id", cascade = CascadeType.ALL)
		private InstructorDetail instructorDetail; 
	}   


	---> @OneToOne => This annotation marks the Instructor class and the Instructor_Detail tables as being in a one-to-one relationship.

		---> Cascade types can also be applied to the @OneToOne and other annotation mappings: 

			---> PERSIST, REMOVE, REFRESH, DETACH, and MERGE enum values all correspond to the different states of entities described above. 

			---> Defining the "cascade" property as any of these transfers the state to child classes in the relationship. 

			---> The ALL enum value specifies all states to be transferred between relationships. 

			---> Cascade needs to be explicitly defined in the relationship annotations. 



	---> @JoinColumn => This annotation provides a references to the foreign key in the Instructor class. 

		---> There is no foreign key field that is explicitly defined here. 


	---> Reminder: 

		---> The child class / table owns the foreign key. 

		---> The parent class / table contains the primary key that is being referenced by the foreign key of the child class. 



Bi-directional One-to-One Mappings:

---> In a bi-directional relationship, it is possible to get both entities from the other entity via a persistence context operation. 

	---> E.g. We can get entity A from B and entity B from A, regardless of who is the parent or child in the relationship. 

	---> This is akin to a double linked list prev and next reference set where both nodes can be accessed from each other. 

		---> Important: It is always important to draw analogies to data structures that are constructed via OOP and situations that arise from technologies such as frameworks and libraries. 

			---> In this case, the "reference" to an entity is the @OneToOne, @OneToMany, etc annotations that are used with the field associated to the other entity. 

			---> These will define the "parent" or "child" in the class.  


---> Example => InstructorDetail and Instructor entity classes:

	@Entity
	@Table(name = "instructor_detail")
	public class InstructorDetail {

		@OneToOne(mappedBy = "instructorDetail", cascade = CascadeType.ALL)
		private Instructor instructor; 
	}
	

	@Entity 
	@Table(name = "")
	public class Instructor {

		@OneToOne(cascade=CascadeType.ALL)
		@JoinColumn(name = "instructor_detail_id")
		private InstructorDetail instructorDetail; 
	}
	


	---> A @OneToOne annotation is added to the second entity class in order to give it a reference to the first class. 

		---> The mappedBy argument refers to the the corresponding field that the entity occupies in the other class. 

		---> mappedBy instructs hibernate to look at the specified property of entity B (2nd entity in relationship) that exists within entity A. 

			---> After locating the property in class A, the infromation provided by @JoinColumn (ie the specified foreign key) is used to find entity A. 


		---> The above sequence of events is assumed to start from a query that executes with respect to class B and needs to access the reference to class A. 

		---> Cascading can be added to the @OneToOne annotation in class B in order to allow operations to flow from B to A in the second directional. 

			---> Note: This is the concept of "directionality" at work in entity / table relationships. 

			---> Operations, within a certain scope, flow in one (uni) or both (bi) directions between entities. 

			---> This represents the causal quality that exists in entity relationships. 


	---> Example of applying a bi-directional relationship: 

		InstructorDetail tempInstructorDetail = session.get(InstructorDetail.class, theId); 
		Instructor instructor = tempInstructorDetail.getInstructor(); 

		---> Under the hood, getInstructor() will be able to access the underlying Instructor database table in order to get the information related to the instructor associated to the InstructorDetail instance used here. 


---> Note on deleting associated entities: 

	---> Selective deletion of A or B only => This involves needing to set the cascade type of eht entity to be deleted to exclude removal cascades, so that only itself is deleted. 

		---> Additionally, the object to be deleted must be dissociated (via setting its partner's field for it to null for example) so that errors will not occur during deletion. 


	---> Therefore, objects in advanced mapping situations need to have their entity fields carefully managed in order to ensure that writes and reads are properly done. 

		---> This is done programmatically.  		
		



Bi-directional One-to-Many Relationships: 

---> As with one-to-one relationships, one-to-many and many-to-one relationships are ubiquitous in entity-entity relationships. 

---> Inside of this relationship, the following standard is used: 

	A. Parent => This is the primary key holder, ie the "One". 

	B. Child / Children => This is the foreign key holder, ie the "Many".

	C. Owner => The owners of this are the children since they hold the foreign key. 


---> The following represents a bi-directional setup for this mapping in Hibernate / JPA: 

	
	A. Parent class: 

	@Entity
	@Table(name = "instructor")
	public class Instructor {

		@OneToMany(mappedBy = "instructor", 
			   cascade = {CascadeType.PERSIST, CascadeType.MERGE, 
				       CascadeType.DETACH, CascadeType.REFRESH})
		private List<Course> courses; 
	}

	---> @OneToMany defines the parent, with mappedBy being told to look at the relevant property in the child class. 

		---> The information in the @JoinColumn name is use to locate the foreign key in the child class and use said key to search for all children records in the database. 

		---> This helps to retrieve the children instances with the parent instance within the relationship. 
 

	B. Child class: 

	@Entity
	@Table(name = "course")
	public class Course {

		@ManyToOne
		@JoinColumn(name = "instructor_id", 
			    cascade = {CascadeType.PERSIST, CascadeType.MERGE, 
				       CascadeType.DETACH, CascadeType.REFRESH})
		private Instructor instructor; 
	}

	---> @ManyToOne defines the child class and @JoinColumn defines the foreign key that is owned by the class. 

	---> Cascading behavior is defined in a more fine grained way to exclude cascading deletes from both parent and child entities. 

		---> Delete behaviors are a situation that must be considered carefully when applying ORM mappings. 	


---> Reminder: It is important to make sure in-memory associations are set between the entities in a relationship before committing during transactional work, otherwise the full relationship will not be defined. 



Fetch Types: Eager vs Lazy. 

---> Data fetching is synonomous with loading data from the database. 

---> In data fetching there are 2 types of loading: 

	A. Eager loading => Loads all dependent entities inside of a relationship. 

		---> E.g. One-to-Many relationship for A-B => All of children B and parent A will load. 

		---> This can have large performance drawbacks if the load on database requests is very high. 

			---> This is especially true for Many-to-Many relationships, where a graph of data is retrieved and can contain many different components / nodes. 

		---> Therefore, eager loading is not considered a performance best practice in development and lazy loading is preferred.


	B. Lazy loading => Loads only the main entity, asked for by the application code, first and then will only load the dependent / associated entities "on demand". 

		---> Lazy loading requires a continously open Hibernate session / persistence context in order to maintain a database connection that allows data loading at a later time when the request for the data ia created. 

			---> Closed sessions / persistence contexts will result in exceptions being thrown in the application. 

		
		---> Lazy loading can be implemented either using session.get() and the appropriate getter methods on the main retrieved entity, which selectively call the dependent objects in the relationship. 

			---> With lazy loading other object fields will likely be null until the getter methods are used.

		---> Another way is via HQL or SQL in createQuery() / createNativeQuery() methods. 

`		---> Note: On-demand / on-request means that the dependent entities are programmtically asked for in application code. 

			---> Breakpoints can be used with a debugger to see the "on-demand" quality that occurs with lazy loading. 



---> Use cases determine whether or not eager vs lazy loading is to be used.  

	---> In certain views / pages, all the information encompensed by a relationship needs to be presented so eager loading should be used to load the main entity and its dependent entities. 

	---> In other views, a selective presentation of information implies a use for lazy loading to only load the main entity in a relationship. 


---> Default fetch types exist for different relationship mappings: 

	A. 1-1 + *-1 => This uses eager loading since the dependent entity is only 1 in number. 

	B. *-* + 1-* => This uses lazy loading since the dependent entities are many in number. 

	---> Fetch types are explicitly overrided in the @OneToOne, @OneToMany, etc relationship annotations with the fetch property (examples defined elsewhere). 


---> Note: Data from a lazy loaded object can be obtained and retained after the persistence context closes using one of 2 ways: 

	A. Using a getter method to copy the data over to a variable that is retained after the session is closed. 

	B. Using a query object to execute either an HQL / JPQL query or a native query in order to fetch the data. 

	---> An example of the query method is shown below: 

	 entityManager.createNativeQuery(
		"SELECT something FROM somethingCOLUMN where something.name = something")
		.setMaxResults(10)
		.getResultList(); 


	---> The query is created with the entity manager for the case of JPA. 

	---> A query object can be created itself if using Hibernate directly. 

		---> This will allow the query itself to be used as a variable. 

	---> Note that the data can be extracted either via getter or via query to variables in order to retain a local copy of their use for later. 


One-To-Many Uni-Directional Mappings: 

---> In addition to the bi-directional format, it is important consider the case of uni-directional one-to-many relationships. 


---> Below is how to set this up for two entity classes: 


	A. Parent: 

	@Entity
	@Table(name = "course")
	public class Course {

		@OneToMany(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
		@JoinColumn(name = "course_id")
		private List<Review> reviews; 

	} 


	---> Note: The @JoinColumn annotation is defined on the parent side of the relationship in order to refer to the foreign key in the child entity class. 

		---> See notes below for why this is the case (@JoinColumn theory). 

	---> FetchType.LAZY defines lazy loading to be used for the child entities that are associated to the parent. 

	

	C. Child: 
	
	@Entity 
	@Table(name = "reviews") 
	public class Reviews {

		...no reference to parent entity defined as a field...

	} 

	---> Theory => Every object type field in a class is a reference (ie "pointer) to another object that is placed inside of it. 

		---> This concept is what allows class instances to "point" to each other forming more complex data structures.               

		---> The idea of a "node" is simply replaced by another class / type.  

		---> Hence compositions of classes are ultimately data structures of variosu types.                


	---> In this example, since this is a uni-directional relationship, no references to the parent occurs, resulting in a one way link.                 



Extra: @JoinColumn theory: @JoinColumn is defined in either the parent or child class depending on the directionality of the relationship. 

		---> The foreign key location, in the context of the ORM mapping, can be dependent on the context of the situation. 

		---> There can be different contexts: 

			A. Unidirectional OneToMany => The foreign key location is in the "target" entity (ie the parent).

			B. Bidirectional OneToMany => The foreign key location is in the "source" entity (ie the child) 
 

		---> Note: Joins can flow in different directions. 

			---> A left or right join involves a source table set of columns being merged with a target table set of columns. 

			---> Therefore, the columns move from "left to right" or "right to left" depending on the join specified. 

			---> In Hibernate, this notion also translates for @JoinColumn to denote foreign key locations. 

				---> The location of the foreign key is dependent on the "strategy" that is used. 

				---> The term "strategy" is defined as the approach used to join tables, which has several possibilities: 

					A. Foreign key mapping strategy => Use a foreign key reference in a child table to refer to the primary key in the parent. 

						---> This facilitates direct joins between both tables.   

					B. Join table strategy => This uses an intermediate table containing the foreign keys of both tables / entities. 

						---> This facilitates joins from both tables to the intermediate table and can be used as a way to enforce bidirectional relationships. 

						---> The join stable strategy also form the basis for more advanced data modeling techniques such adjacency lists and nested sets. 


			---> The definitions of "source" and "target" in terms of primary and foreign key holders are as follows: 

				A. Source => Holder of the primary key being referenced to in the relationship. 

				B. Target => Holder of the foreign key.  

	
			---> The relationship annotations and their usage between 2 entities in a relationship will inform Hibernate on the implicit strategy to be used for joins. 

				---> This in turn will influence the location that Hibernate places the foreign key reference, and hence the location of the @JoinColumn annotation in the parent - child relationship. 




Many-to-Many Relationships in Hibernate: 

---> A many-to-many relationship is one in which an entity of one table can have a relationship with an entity of another table and vice versa. 

	---> Entity A can be associated with many of Entity B. 

	---> Entity B can be associated with many of Entity A. 


---> Fundamentally, this is best represented by a graph data structure in-memory when considering entity objects. 

---> For many-to-many relationships, a common join strategy is to use a join table (as denoted above). 

	---> The join table is an intermediary table that provides a mapping between tables A and B via foreign keys. 

	---> The primary keys of each table are included as foreign key columns on the table. 

	---> A join table effectively defines a bi-directional relationship between 2 tables. 

 	---> An example of join table logic is presented below: 

		1. Joining a column in table A to the join table. 

		2. Then joining a column in table B to the join table. 

		3. Both are joined on the same row because their primary keys are fixed to the same row in the join table. 

		4. The data is now represented on one row. 

		---> More will be written on the DML SQL syntax needed in order to make such queries. 

	
	---> Note: In order to ensure that the mapping between A and B are complete, the primary key of the join table must be a composite primary key. 

		---> The composite primary key consists of foreign key columns corresponding to the primary keys in tables A and B. 

		---> This is done to ensure that unique mappings between A and B are created. 

		---> The mappings can be adjusted by combining foreign keys in desired combinations. 

		---> The concept of a join table doesn't necessarily need to be between just 2 tables, but more tables. 

			---> This is present in the case of complex data modeling strategies such as nested sets and adjacency tables. 


---> A developed example is given below: 

	@Entity
	@Table(name = "course") 
	public class Course {

		@ManyToMany
		@JoinTable(
			name = "course_student", 
			joincolumns = @JoinColumn(name = "course_id"), 
			inverseJoinColumns = @JoinColumn(name = "student_id") 
			)
		private List<Student> students;  
	}


	@Entity 
	@Table(name = "student") 
	public class Student {

		@ManyToMany
		@JoinTable(
			name = "course_student", 
			joincolumns = @JoinColumn(name = "student_id"), 
			inverseJoinColumns = @JoinColumn(name = "course_id")
		)
		private List<Course> courses; 
	}


	---> The @ManyToMany annotation specifies the relationship mapping to Hibernate. 

	---> If a join table strategy is being used, then the @JoinTable annotation must be specified in order to instruct Hibernate to work with the underlying join table in the data source: 


		A. name => This refers to the name of the join table. 

		B. joinColumns => This refers to the names of the foreign keys that are on one side of a mapping in a join table. 

		C. inverseJoinColumns => This refers to the names of the foreign keys which are on the other side of a mapping. 

		---> Note: The join and inverse join columns are defined with respect to which entity is being considered in the relationship (ie which entity @JoinTable is being defined for). 

			---> Consequently, the column definitions will change. 

		---> A mapping can be quite complex, but typically it is a two ended construct. 

			---> More complex mappings will require collections of join and inverse join columns to be defined in these arguments, using @JoinColumn with {}.

			---> The mapping represents the relationship between the tables themselves. 

		---> Therefore, the join column and inverse join column represent the "target" and "source" ends of a mapping, which is represented by a join table. 

		---> @JoinTable is similar to @JoinColumn because it represents the underlying table without explicitly needing to represent the join table as an entity class in the application code. 


	---> Note: @JoinTable must be defined for the other entity in the many-to-many relationship, but with the join columns and inverse join columns reversed. 

		---> This is because this is the other side of the relationship.  		
	




