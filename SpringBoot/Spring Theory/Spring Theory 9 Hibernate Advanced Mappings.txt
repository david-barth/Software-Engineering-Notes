Advanced Mapping Concepts: Hibernate (with SQL notes where necessary) 


Introduction to Advanced Mappings in Hibernate: 

---> Advanced mappings cover the cases of multiple tables in a database having relationships between each other. 

---> Reminder: Relationships are usually defined via the use of a foreign key (e.g. a primary key of a table) being present in another table. 

	---> The foreign key refers to the partner table and is therefore what binds tables together in a logical relationship. 


---> There are many different ways to consider the relationship including complex usages like relationship directionality, but the 4 main relationships here are: 


	A. One-to-One

	B. One-to-Many

	C. Many-to-One

	D. Many-to-Many

	---> Each can have different usages of foreign keys.  

	---> Important: A-C are effectively tree data structures while Many-to-Many is a graph data structure. 


Reinforcement of Database Concepts: 

---> Basic notes on the use cases of foreign keys and primary keys can be found in the SQL notes. 

---> Here the focus is on cascading, which is a term describing the same operation being applied to the same entities. 

	---> Ie if an entity A is updated and a cascade exists between A and B, then entity B will also be saved.  

	---> This is also equally the case for deleting entities in a relationship too, but the use case for deletion cascades must be carefully considered. 


---> Another concept that is considered is loading: 

	---> This determines whether all data related to an entity is retrieved all at once or on request: 
	
	---> There are 2 types of loading: 

		A. Eager loading => This type of loading retrieves every entity that is associated with an entity being retrieved. 

			---> This type of loading has performance implications due to the volume of data that is retrieved, especially in the case many-to-many relationships. 

	
		B. Lazy loading => This type of loading retrieves related entities only on request.  

			---> Lazy loading is more efficient performance wise for applications. 


---> Directionality is also a consideration between 2 entities: 

	A. Uni-directional => This implies a one way relationship between entities A and B in which entity A can access entity B, but not the other way around. 

	B. Bi-directional => This implies a two way relationship between entities A and B in which either entity can access the other via references. 



One-to-One Relationships in Hibernate: 

---> A foreign key relationship is meant to do 2 things: 

	A. Link tables together into a relationship. 

	B. Allow parent-child tables to be joined together in join operations for queries. 

	C. Maintain referential integrity between the 2 tables. 

	---> In other words, 2 tables linked together by a foreign key are protected from operations that would destroy that relationship. 

	---> Only valid data is inserted into the foreign key column, which is usually the primary key of the other table (ie parent table). 


---> In Hibernate, an entity also has a life cycle that is similar to a bean.  There are 5 operations associated with the entity lifecycle: 

	A. Detach => Allows an entity to be detached or dissociated from a Hibernate session. 

	B. Merge => Assoicates a detached entity to a session. 

	C. Persist => This transitions entities to a managed state, which allows the entity to be saved in the DB on the net flush / commit. 

	D. Remove => Transitions a managed entity to be removed such that the next flush / commit will delete the entity from the DB. 

	E. Refresh => Reloads / Resynchronizes data the entity with data from the DB preventing stale data. 


	---> Each of these operations also corresponds with a CRUD method that is associated with the EntityManager of the JPA specification. 

	---> Note: "Flushing" means to synchronize the temporary state of application data with the permanent state of data from a database or hard disk. 

		---> This is almost the inverse of committing in which application data is used to update the state of corresponding data in the datanase. 


	---> In the Hibernate entity lifecycle, there is an implicit set of states and thus locations for an entity: 


		A. Client Code (Application Code) => The application business layer is the "client" code that makes use of the API provided by the persistence context in order to interact with the database. 

			---> Here is where entities in a "detached" state occur and detached entities are not tracked by the persistence context. 

			---> Detached entities can be merged to the persistence context in order to become a managed entity. 

				---> The detached entity is simply a POJO that has an identity value corresponding to a database row. 

				---> The Id is all that is necessary in order to allow the persistence context to connect the detached entity to its corresponding data in the database. 


			---> Transient entities are also found in the application / client code, but have no Id corresponding to an identity in a database record. 

				---> These are simply objects that have been created in application code (e.g. as DTOs), which could be made persistent via persistence context methods.  




		B. Persistence Context => This is a staging area where persistent data and entities are interconverted amongst each other during transactions. 

			---> This is an implementation of the Unit of Work design pattern and is similar in concept to the git staging area. 

			---> Here, changes to the data are tracked and these changes are synchronized to the database at the end of a transaction. 

			---> EntityManager and Session are implementations of the persistence context. 

			---> All entities that are managed by the persistence context are "merged" with it, as described above. 

				---> Therefore, merged entities have changes tracked.  

			---> In this sense, the persistence context acts as a container for entities in a similar way as the Spring Container / context does for beans. 
 
			---> Managed entities are always persistent in that each has a database identifier, even if it doesn't exist in the database just yet. 

			---> An entity that has a "deleted" state is marked for deletion and therefore removal from the DB via the persistence context.  

				---> The deleted state entities are still attached to the persistence context.    


		C. Data Store => This is where the persistent data is found and the ORM interacts with this layer.  


---> Additional note: A transaction is called a "unit of work" and here both client code + SQL operations can be performed in the overall application architecture. 

	---> This work includes any persistence context operations 

	---> When a transaction is opened, all code execution in that period of time is devoted to the interaction of database with the persistence context and the client code.

	---> There are 2 conclusions of a transaction: 

		A. Commit => Used to save changes of a current transaction in a permanent way. 

		B. Rollback => Used to undo changes made on the curren transaction. 

	

--->  The following example uses 2 classes and 2 tables: Instructor + Instructor_detail (InstructorDetail in entity form)


	@Entity
	@Table(name = "instructor")
	public class Instructor {

		@OneToOne
		@JoinColumn(name="instructor_detail_id", cascade = CascadeType.ALL)
		private InstructorDetail instructorDetail; 
	}   


	---> @OneToOne => This annotation marks the Instructor class and the Instructor_Detail tables as being in a one-to-one relationship.

		---> Cascade types can also be applied to the @OneToOne and other annotation mappings: 

			---> PERSIST, REMOVE, REFRESH, DETACH, and MERGE enum values all correspond to the different states of entities described above. 

			---> Defining the "cascade" property as any of these transfers the state to child classes in the relationship. 

			---> The ALL enum value specifies all states to be transferred between relationships. 

			---> Cascade needs to be explicitly defined in the relationship annotations. 



	---> @JoinColumn => This annotation provides a references to the foreign key in the Instructor class. 

		---> There is no foreign key field that is explicitly defined here. 


	---> Reminder: 

		---> The child class / table owns the foreign key. 

		---> The parent class / table contains the primary key that is being referenced by the foreign key of the child class. 



Bi-directional One-to-One Mappings:

---> In a bi-directional relationship, it is possible to get both entities from the other entity via a persistence context operation. 

	---> E.g. We can get entity A from B and entity B from A, regardless of who is the parent or child in the relationship. 

	---> This is akin to a double linked list prev and next reference set where both nodes can be accessed from each other. 

		---> Important: It is always important to draw analogies to data structures that are constructed via OOP and situations that arise from technologies such as frameworks and libraries. 

			---> In this case, the "reference" to an entity is the @OneToOne, @OneToMany, etc annotations that are used with the field associated to the other entity. 

			---> These will define the "parent" or "child" in the class.  


---> Example => InstructorDetail and Instructor entity classes:

	@Entity
	@Table(name = "instructor_detail")
	public class InstructorDetail {

		@OneToOne(mappedBy = "instructorDetail", cascade = CascadeType.ALL)
		private Instructor instructor; 
	}
	

	@Entity 
	@Table(name = "")
	public class Instructor {

		@OneToOne(cascade=CascadeType.ALL)
		@JoinColumn(name = "instructor_detail_id")
		private InstructorDetail instructorDetail; 
	}
	


	---> A @OneToOne annotation is added to the second entity class in order to give it a reference to the first class. 

		---> The mappedBy argument refers to the the corresponding field that the entity occupies in the other class. 

		---> mappedBy instructs hibernate to look at the specified property of entity B (2nd entity in relationship) that exists within entity A. 

			---> After locating the property in class A, the infromation provided by @JoinColumn (ie the specified foreign key) is used to find entity A. 


		---> The above sequence of events is assumed to start from a query that executes with respect to class B and needs to access the reference to class A. 

		---> Cascading can be added to the @OneToOne annotation in class B in order to allow operations to flow from B to A in the second directional. 

			---> Note: This is the concept of "directionality" at work in entity / table relationships. 

			---> Operations, within a certain scope, flow in one (uni) or both (bi) directions between entities. 

			---> This represents the causal quality that exists in entity relationships. 


	---> Example of applying a bi-directional relationship: 

		InstructorDetail tempInstructorDetail = session.get(InstructorDetail.class, theId); 
		Instructor instructor = tempInstructorDetail.getInstructor(); 

		---> Under the hood, getInstructor() will be able to access the underlying Instructor database table in order to get the information related to the instructor associated to the InstructorDetail instance used here. 


---> Note on deleting associated entities: 

	---> Selective deletion of A or B only => This involves needing to set the cascade type of eht entity to be deleted to exclude removal cascades, so that only itself is deleted. 

		---> Additionally, the object to be deleted must be dissociated (via setting its partner's field for it to null for example) so that errors will not occur during deletion. 


	---> Therefore, objects in advanced mapping situations need to have their entity fields carefully managed in order to ensure that writes and reads are properly done. 

		---> This is done programmatically.  		
		



Bi-directional One-to-Many Relationships: 

---> As with one-to-one relationships, one-to-many and many-to-one relationships are ubiquitous in entity-entity relationships. 

---> Inside of this relationship, the following standard is used: 

	A. Parent => This is the primary key holder, ie the "One". 

	B. Child / Children => This is the foreign key holder, ie the "Many".

	C. Owner => The owners of this are the children since they hold the foreign key. 


---> The following represents a bi-directional setup for this mapping in Hibernate / JPA: 

	
	A. Parent class: 

	@Entity
	@Table(name = "instructor")
	public class Instructor {

		@OneToMany(mappedBy = "instructor", 
			   cascade = {CascadeType.PERSIST, CascadeType.MERGE, 
				       CascadeType.DETACH, CascadeType.REFRESH})
		private List<Course> courses; 
	}

	---> @OneToMany defines the parent, with mappedBy being told to look at the relevant property in the child class. 

		---> The information in the @JoinColumn name is use to locate the foreign key in the child class and use said key to search for all children records in the database. 

		---> This helps to retrieve the children instances with the parent instance within the relationship. 
 

	B. Child class: 

	@Entity
	@Table(name = "course")
	public class Course {

		@ManyToOne
		@JoinColumn(name = "instructor_id", 
			    cascade = {CascadeType.PERSIST, CascadeType.MERGE, 
				       CascadeType.DETACH, CascadeType.REFRESH})
		private Instructor instructor; 
	}

	---> @ManyToOne defines the child class and @JoinColumn defines the foreign key that is owned by the class. 

	---> Cascading behavior is defined in a more fine grained way to exclude cascading deletes from both parent and child entities. 

		---> Delete behaviors are a situation that must be considered carefully when applying ORM mappings. 	


---> Reminder: It is important to make sure in-memory associations are set between the entities in a relationship before committing during transactional work, otherwise the full relationship will not be defined. 



Fetch Types: Eager vs Lazy. 

---> Data fetching is synonomous with loading data from the database. 

---> In data fetching there are 2 types of loading: 

	A. Eager loading => Loads all dependent entities inside of a relationship. 

		---> E.g. One-to-Many relationship for A-B => All of children B and parent A will load. 

		---> This can have large performance drawbacks if the load on database requests is very high. 

			---> This is especially true for Many-to-Many relationships, where a graph of data is retrieved and can contain many different components / nodes. 

		---> Therefore, eager loading is not considered a performance best practice in development and lazy loading is preferred.


	B. Lazy loading => Loads only the main entity, asked for by the application code, first and then will only load the dependent / associated entities "on demand". 

		---> Lazy loading requires a continously open Hibernate session / persistence context in order to maintain a database connection that allows data loading at a later time when the request for the data ia created. 

			---> Closed sessions / persistence contexts will result in exceptions being thrown in the application. 

		
		---> Lazy loading can be implemented either using session.get() and the appropriate getter methods on the main retrieved entity, which selectively call the dependent objects in the relationship. 

			---> With lazy loading other object fields will likely be null until the getter methods are used.

		---> Another way is via HQL or SQL in createQuery() / createNativeQuery() methods. 


---> Use cases determine whether or not eager vs lazy loading is to be used.  

	---> In certain views / pages, all the information encompensed by a relationship needs to be presented so eager loading should be used to load the main entity and its dependent entities. 

	---> In other views, a selective presentation of information implies a use for lazy loading to only load the main entity in a relationship. 


---> Default fetch types exist for different relationship mappings: 

	A. 1-1 + *-1 => This uses eager loading since the dependent entity is only 1 in number. 

	B. *-* + 1-* => This uses lazy loading since the dependent entities are many in number. 

	---> Fetch types are explicitly overrided in the @OneToOne, @OneToMany, etc relationship annotations with the fetch property (examples defined elsewhere). 

