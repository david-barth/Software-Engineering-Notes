Spring Theory 8: Introduction to Hibernate


Basic Introduction: 

---> Hibernate is a framework that implements the Java Persistence API specification and is used to persist objects in a database.        

	---> Hibernate acts as a wrapper around JDBC code that would otherwise need to be written in order to handle querying databases. 



---> In functionality, Hibernate uses Object-to-Relational Mapping (ORM) in order to query and persist data into / out of databases. 

	---> The ORM approach allows a developer to define a mapping between a Java class to a database tables based on the following analogies: 

		A. Class <-> Table

		B. Field (Primitive) <-> Column => This applies to primitive values only (e.g. int <-> int, String <-> carchar, etc)

		---> The Class <-> Table mapping also applies to nested objects that are part of a field of an encapsulating object in a similar sense to how a foreign key in one table references a column in another table, associating the 2 tables together in some way. 


	---> Under the hood, Hibernate automatically implements SQL code to write an object to a database or to read data from the database based on the relational mappings defined in the entity objects. 


Hibernate Annotations: 

---> In Hibernate, the modern approach to ORM is via the use of annotations.  

---> There are several key annotations to consider: 

`	A. @Entity => A class level annotation that specifies to Hibernate that this class will ultimately map to a table in the database. 

	B. @Table => A class level annotation that is used with @Entity to specify which table in the database the table maps to. 

	---> @Entity will by default map to a potential table with a default name that is a lowercase version of the class name.

	---> @Table specifies the name of the table to be mapped to explicitly (via the name property) and also includes other aspects related to the table schema (to be explored). 


	C. @Id => This specifies a field of a class as mapping to the primary key column of a database. 

	D. @Column => This allows an explicit mapping to be defined between the property and the column via the explicit column name in the database should the field name differ from the column name. 

		---> This is best used to explicitly map the field to the column name and is considered a best practice. 


---> Note: It is important that getters / setters + a constructor exists for the entity class so that informatin can be mapped to and from the field when interacting with the database. 

---> Note 2: The above annotations constitute as JPA annotations which are considered best practice for use with Hibernate. 

	---> Hibernate is an implementation of JPA, which is a standard specification.  Therefore Hibernate implements the JPA annotations internally, allowing them to be used without a problem. 



Hibernate: CRUD Operations. 

---> In normal considerations, an application must always open up a connection to a database in order to perform transactions with it. 

	---> These database connections are analgous to HTTP transactions in some ways given that they represent a unit of work, but these connections also have a higher level of "safety compliances" by (ideally) obeying ACID principles. 


---> In Hibernate, on the bean level the above concept is represented as follows: 

	A. Session => This is a short-lived object that acts as a wrapper around a JDBC connection to a database. 

		---> It it through a session (and hence a database connection) that transactional work can be done. 

		---> It is shortlived and exists primarily to write / read objects from an underlying database. 


	B. SessionFactory => This class produces Session objects to be used with Hibernate for transactional work and implements a factory design pattern. 

		---> The SessionFactory is long lived and exists throughout the lifecycle of the application instance. 

		---> The information from the hibernate config file is read by the SessionFactory in order to configure the Session objects properly (ie configure the underlying JDBC connections). 


---> The configuration for the SessionFactory is shown below: 


	SessionFactory factory = new Configuration()
				.configure("hibernate.cfg.xml")
				.addAnnotatedClass(Student.class)
				.buildSessionFactory(); 

	Session session = factory.getCurrentSession(); 
	
	try {

		Student tempStudent = new Student();
		session.beginTransaction(); 
		session.save(tempStudent);
		session.getTransaction().commit();  

	}  finally {
		factory.close(); 
	}	


	---> The above configuration is likely placed into a Spring configuration file in order to configure SessionFactory and Session beans. 

		---> The SessionFactory and the Session object are both beans.  

			---> The SessionFactory is a Singleton scope bean whereas the Session object is potentially a prototype scope bean since it is created with every new request to query an object. 


	---> Note: The try - finally block can be used to handle th eopening of a connection and then the closing of a connection (regardless of exception catches) in order to free up resources. 

		---> This appears to be a common usage pattern in application development. 


	---> The session object contains all the necessary methods for transactions. 

		---> session.beginTrasnaction() opens up a transaction and any query-like operations that are used here can be used within the transaction. 

			---> Reminder: The transaction represents the fundamental unit of work for application - database interactions. 


		---> session.getTransaction().commit() allows all work in the transaction to be committed, such that the transaction is considered closed. 



Hibernate and Primary Keys: 

---> Notes have already been included in practical notes for databases regarding the practical usages of primary keys in databases. 

---> In Hibernate, as mentioned above, the primary key is defined on the entity class by using the @Id annotation the desired field value. 

---> The primary key itself can be generated, inside of a database, through the use of different "strategies" or algorithm: 

	A. Auto-incrementing => This involves using an identity column to uniquely assign primary keys to records upon creation. A new record recieves an incremented key (incremented by 1). 

	B. Sequences => This involves using a sequence to provide primary key generation, which is popular in PL/SQL (oracle DB). 

	C. Table => This uses an underlying database table to assign primary keys to ensure unqiueness. 
 

---> In Hibernate, each of these primary key generation methods are captured in the @GeneratedValue(strategy = "...") annotation, which has 3 variations mapping on to the above: 


	A. GenerationType.IDENTITY => Auto-incrementing 

	B. GenerationType.SEQUENCE => Sequences

	C. GenerationType.TABLE => Table

	D. GenerationType.AUTO => This determines the most appopriate strategy for a particular database given configurational situations. 

	---> The enums of A-C are used to insert the desired value generation mechanism that Hibernate implements when an object is saved to the database. 

	---> It is also possible to create a custom strategy, but this is beyond the scope of these notes here. 

	---> It is noted that MySQL server is responsible for the auto-increment of values. 


---> Note: The auto-increment starting value of a primary key can be changed via the following SQL statement: 

	ALTER TABLE tableName AUTO_INCREMENT=3000; 

	---> This alter statement targets a variable called AUTO_iNCREMENT


---> Note 2: To delete database rows and to reset the primary key value to 0: 

	TRUNCATE Database.tableName; 

	---> The TRUNCATE keyword acts as a reset button for the database, deleting all rows from all tables and resetting the primary key values to 0. 

	---> The syntax of Database.tableName can be used to access tables from databases, even when inside of my database already. 

		---> Note the similarity to object dot notation in Java. 


Reading Objects with Hibernate: 

---> The Session object of Hibernate is responsible for facilitating all CRUD operations that can be performed from the application to the DB. 

---> The following example shows how the session object does this with read operations: 

	session.get(SomeObject.class, theStudent.getId()); 

	---> The class is used in order to create an object, which is filled by information from a record find by retrieving the primary key of the database record. 

	---> The following represents the equivalent operation via the JPA EntityManager class: 

	entityManager.find(someObject.class, ...query criteria...);

	---> The JPA entityManager will use the find() method in an analogous manner. 


 Querying Objects with Hibernate: 

---> Queries can also be performed either natively using HQL (or a JPA query language) or using a native query.  

---> The following represents examples from Hibernate and JPA: 

	1. JPA: Using the query language in JPA: 
 
		entityManager.createQuery(...query in JPQL); 
		

	2. JPA: Using a native query: 

		entityManager.createNativeQuery("Select * from tableName"); 

	
`	---> The same methods can also be analgously applied to Hibernate Session objects too. 


	3. JPA Spring Data => Using @Query with a repository method or field: 

	@Query(
		value = "SELECT * FROM Table", 
		nativeQuery = true; 
	)

	---> @Query allows a query to be defined either using JPQL or SQL to perform the query. 
 	
	---> Note: @Query is used with repository interfaces that inherit from the CrudRepository or JpaRepository interfaces. 

		---> For custom repo classes, the EntityManager / Session methods are used instead. 


---> Note: It is important to collect the resulting data structure that comes from the query method. 

---> This responds to the following: 

	session.createNativeQuery("select * from Table").getResultList(); 

	---> This extracts the list that is obtained from the query itself. 


Updating Objects in JPA / Hibernate: 

---> There are a few ways to update an object in Hibernate or JPA: 

	A. Updating the entity class via setter method and committing the object. 

		Student myStudent = session.get(Student.cclass, studentId); 
		myStudent.setFirstName("Something"); 
		session.getTransaction().commit(); 
		
		---> The above represents an example of updating the object by setting a value and setting a value to one of those fields. 
	
		---> Reason => The object retrieved is a persistent object and so recommitting it will update the object because its mapped version has changed. 


	B. A query can also be programmtically created to update many different objects or a complex combination of objects: 

		session.createNativeQuery("UPDATE table_name set column1 = someValue, column2 = some Value, WHERE condition")
		       .executeUpdate();


		---> The above executeUpdate() method is also used with the EntityManager class. 

			---> Important => Outside of basic read / write operations, many query based methods (e.g. createNativeQuery(), createQuery(), etc) are shared by Hibernate and the JPA specification. 

			---> Reason => Hibernate is an IMPLEMENTATION of JPA.  


		---> The above also applies for createQuery(), but using HQL / JPQL instead of SQL. 


Deleting Objects with Hibernate: 

---> Similar to updating, deleting objects is also divided into 2 possibilities: 
 
	A. Deleting a single object via delete() (Hibernate) or remove() (JPA EntityManager): 

		entityManager.remove(someObject); 

		or 

		Student myStudent = session.get(Student.class, studentId); 
		session.delete(myStudent);
		session.getTransaction().commit(); 

		---> Under either of these examples, the object is retrieved from the DB and then deleted using remove() / delete(). 

		---> Note about transactions: 

			---> For JPA, @Transactional will automatically delegate the transaction management to Spring for the annotated DAO / Repo class. 

			---> In explicit Hibernate (and JDBC), transaction management may need to be managed manually with explicit handling of the session object, if proper lifecycle methods are not used (@PreDestroy and @PostConstruct)


	B.  Deleting multiple objects or complex deletions can once again be achieved via a query or native query: 

		entityManager.createNativeQuery("DELETE FROM table_name where condition")
			     .executeUpdate(); 

		---> Once more, executeUpdate() is used because update and update operations both represent "update" writes to the database and so are handled with the same method name in Hibernate / JPA Spring Data. 

		---> Note on SQL => DELETE statements require a WHERE clause in order to selectively delete records.  

			---> More information on this will be found in SQL notes (practical and theoretical). 


		---> Like with update operations, this is all done in the context of a transaction. 


Review of Basic CRUD functionality for Hibernate vs JPA: 

---> Reminder => JPA is the specification and there are multiple implementations of it, including Spring Data JPA and Hibernate. 

---> In terms of differences: 

	A. Query methods: For the most part, basic query methods such as createQuery(), createNamedQuery(), and createNativeQuery() are quite similar between Hibernate and JPA. 

		---> The differences are mostly in the query languages used for non-native queries, which is HQL vs JPQL. 


	B. Basic CRUD methods: There are naming differences in the basic CRUD methods between JPA and Hibernate: 

		---> persist() vs save()

		---> remove() vs delete() 

		---> find() vs get()

		---> All the above are the JPA vs Hibernate methods. 




 

