Spring Theory 7: REST Web Services with Spring. 


Introduction to REST Web Services and REST in general: 

---> REST stands for Representational State Transfer and is a set of architectural principles that are best used for the needs of web services and mobile applications. 

---> These architectural guidelines are 6 in total: 


	1. A client-server architcture which is composed of: 

		A. Clients => Machines that issue requests for resources. 
	
		B. Server => Machines that respond to requests from clients and contain the desired resources. 

		C. Resources => Data that is sent back as a response to the client by the server and is contained on the server.


	2. Stateless client-servercommunication wherein infromation about a session's state is held by the client and no client content is stored on the server between requests.   

		---> Ie the state of the client is not known by the server during the course of a transaction. 


	3. Cacheable data on the client side in order to eliminate certain client-server interactions (e.g. cookies). 

		---> These are used as a way to optimize performance. 


	4. A uniform interface between components so that information is transferred in a standardized form that is not specific to an application. 

		---> An example is using HTTP transactions with a form of data encoding, such as JSON, for all applications.  

	5. A layered system, wherein client-server interactions are mediated by hierarchal layers. 


	6. Allowing servers to extend functionality of a client by transferring executable code.


	---> In practice, REST is implemented by using HTTP as a networking protocol. 

	---> On the API side, requests and responses are serialized into common formats such as HTML, XML, JSON, etc. 

	---> The HTTP transaction does not include anything from the client side beyond the information needed to retrieve the resource from the server side. 

	---> Many implementations of REST (ie RESTful APIs) map the mechanics of an HTTP transaction, such as HTTP verbs (GET, POST, PUT, etc) onto the resource layers available on the backend server as routes that perfor the analgous HTTP verb action on the server side.              

		---> E.g. A POST route on a Java oriented server will have code that allows for a request body to be receieved as an argument to the route method on the resource controller. 


---> Significantly, a REST architecture is one that is flexible in implementation and merely needs to follow a set of principles.  

	---> Compared other protocols / architectures, such as SOAP (Simple Object Access Protocol), REST can differ in its implementations, with the HTTP based form the most used. 

	---> SOAP is a protocol that contains built-in standards and rules, which must be implemented in order to offer inherent compliances to certain qualities of an application, such as resiliency, ACID, and security. 

		---> E.g. SOAP follows Atomicity, Consistency, Isolation, and Durability (ACID) principles, which are properties of a system that are used for ensuring relaible database transactions. 

		---> Except rather than database communications, this is now generalized as a network protocol. 


	---> The difference is that REST lacks these pieces of overhead in favor of increased performance and less overhead in implementation + development. 

	---> One final difference is that SOAP can be handled via any application layer networking protocol such HTTP, SMTP, TCP, and more. 

		---> REST is commonly limited to HTTP based implementations. 



Introduction to Jackson: Use in Serializing and Deserialzing JSON. 

---> In general, when data is sent between machines over a network, it is encoded in a format that can either be machine readable or human readable or both. 

	---> The process of encoding data between different forms is called data binding. 

	---> Data is bound to one form after an encoding or decoding process. These conversions are known as: 

		A. Mapping => From form A to B and vice versa. 

		B. Serialization / Deserialization 

		C. Marshalling / Unmarshalling

		---> These all refer to the processes of data binding / converting between different forms as data is transmitted over a network. 


---> Data binding in Spring uses a library called Jackson in order to handle conversions between Java objects and JSON / XML encodings. 

---> Jackson uses a mapping process in order to map values from a JSON or XML encoding into a Java object. 

---> For JSON, the conversion of JSON -> POJO (deserialization) is done roughly as follows: 

	ObjectMapper mapper = new ObjectMapper(); 
	SomeObject anObject = mapper.readValue(new File("path/sample.json"), SomeObject.class); 

	---> An ObjectMapper class is used to read values from a data source (in this case a JSON file). 

	---> The data source contains the data encoded in JSON and the object mapper takes in a class of the POJO in order to complete the mapping process. 

	---> Under the hood, Jackson uses the POJO's setter methods to set the values of the POJO fields according to the property names of the JSON encoding. 

		---> For this to work, however, the hierarchal structure of the POJO fields and the names of the fields must match the structure and property names in JSON. 

		---> Speculation => For JSON <-> POJO data binding, the hierarchal nature of JSON structure implies the use of a tree in order to manage conversions. 


---> For the conversion of POJO -> JSON (serialization), the process is: 

	mapper.enable(SerializationFeature.INDENT_OUTPUT); 
	mapper.writeValue(new File("data/output.json"), someObject);

	---> Here, the object mapper writes the field values of a POJO to a new file in the JSON format. 

	---> The mapper uses the POJO getter methods to obtain the values and match them to a JSON file or response.  

	---> In this example, the INDENT_OUTPUT enum option is used to allow for pretty formatting. 


---> For Spring REST applications, Jackson is automatically integrated into Spring. 

	---> Main use case => REST controllers use Jackson based serialization / deserialization methods for JSON data passed into a REST controller or DTOs being passed out through the REST controller. 


---> Nested data in JSON comes in 2 forms: 

	A. Object nestings => For Jackson to handle the data binding, a composite / nested object, matching the structure of the JSON must be designed for the POJO class. 

	B. Array nestings => For this, a List type or an array must be used in order to accommodate the data binding. 

	---> For most use cases of serialization / deserialization in Spring, these structural considerations will be sufficient. 


---> Important => If a new property is added to JSON and this change is not accounted for the POJO, then an exception will be thrown. 

	---> To fix this issue, the @JsonIgnoreProperties annotation can be used on the class level as follows: 

	@JsonIgnoreProperties(ignoreUnknown=true)
	public class SomeClass {
		...
	}

	---> The argument of ignoreUnknown is set to true in order to allow Jackson to ignore properties that are not accounted for in the field values of the Java object. 



Spring REST Controllers: 

---> Spring MVC provides support for REST APIs and architectures via the @RestController annotation. 

	---> @RestController is an extension of @Controller and handles HTTP requests + response transactions. 

	---> Controllers that have @RestController used on the class level automatically handle the serialization / deserialization of JSON and Java objects. 

		---> It is just imporant to havethe Jackson project on the classpath. 



---> Important => The difference between a REST API and a REST architecture is as follows: 

	A. REST API => This is simply the programmatic interface (e.g. on the backend) that helps to implement some of the architectural principles defined above for REST. 

		---> Signficantly, the REST API is an important component in an overall REST architecture. 

		---> Principles supported by the REST API: 

			A. Forming the interface for the communication that the client has with the resources formed inside of the server (Interface + client-server architecture) 

			B. Contains the hierarchal layers needed to mediate client-server "transactions" (Layered architecture) 

			C. Can help to send executable code in certain MIME types (e.g. Already rendered HTML via templating enginges) (Sending executable code). 


	B. REST Architecture => This is the entire architecture of the system that is designed in accordance to the REST architectural principles. 

		---> REST architecture covers everything that is built to support the architectural principles of REST and therefore considers all the principles. 

		---> The REST client (e.g. web browser that consumes a REST API) and the REST service (e.g. a backend REST API) are both part of a REST architecture. 


---> Reminder: In order for a Spring MVC web app projec to to be initialized, in non-SpringBoot configurations, it is important to configure servlet initalization: 

	---> This will help to initialize the dispatcher servlet that serves as the front controller for all other controllers in the web app. 

	---> This can be done via the AbstractAnnotationConfigDispatcherServletInitializer abstract class, which is extended by an inheriting class. 

	---> The required methods must be overrided as well, with the proper steps, which will be detailed in separate notes focused on the dispatcher servlet. 



Reminder: Jackson Integration with Spring + Data binding 

---> Jackson is already integrated under the hood with Spring and Spring will handle this integration as long as Jackson is on the classpath. 

---> Jackson is what will provide the methods needed in order to accomplish the serialization / deserialization of JSON and POJOs, which is handled automatically by the @RestController annotation. 

---> What is worth noting is the case where custom serialization / deserialization needs to be written for special use cases, where the Spring integration cannot handle it.  Currently, Spring + Jackson integration can handle the following use cases: 

	A. Complex composite objects => Where nested JSON data and composed POJOs (consisting of nested object fields) have a direct correspondence in structure. 

	B. Simple primitive objects or lists => Where nested JSON properties have primitive values or arrays of primitive values, which correspond similarly as composite objects in structure. 

	---> The situation becomes more interesting with other more potentially complex data structures or potentially with cases where certain properties or fields need to be ignored. 


 
Using @PathVariable for Query Parameters in REST Endpoints: 

---> In endpoint terminology, a query parameter is used as a way to parameterize a segment of an endpoint in order to account for variable values that could be provided via an URI / URL when accessing an endpoint. 

---> The nomenclature / pattern is: /something/{queryParameter} 

	---> {} marks that section of an endpoint as having variable values.  

	---> This allows for specific data to be targetted when interacting with the endpoint. 


---> In Spring MVC + Spring REST, it is possible to use @PathVariable in order to bind the query parameter to an input that is an argument for a controller method: 

	@GetMapping("/students/{studentId}")
	public Student getStudent(@PathVariable int studentId) {
		...
	} 

	---> Note 1: The studentId query parameter name must match the studentId argument name in the controller method in order to allow the query parameter <-> input binding to occur. 

	---> Important => @Pathvariable is an example of an argument level annotation that affects an input to a method. 

		---> Therefore, annotations can be placed at the class level, method level, field level, or argument level within Java in order to instruct the compiler to generate specific meta code relating to that annotation to the part of the code the annotation refers to. 



Spring REST Exception Handling: 

---> In order to handle exceptions / errors that can occur in a REST endpoint call, the following components need to be taken into account: 

	A. Custom Error Response Class => This is the DTO that is serialized into JSON in order to inform the client that an error situation has occurred. 

		---> This typically contains the error message and the response status code, which are transferred from either the exception or from other sources in the resource behidn the endpoint. 


	B. Custom Exception Class => This is a custom exception that is generated for an exceptional error situation that is likely to occur within the situational context of the application. 

		---> This exception usually ends up extending a base Exception class such as RunTimeException with custom behavior expressing the error situation that it is meant to handle. 



	C. @ExceptionHandler => This annotation allows for exception handling behavior to be implemented. 

		---> The exception handler returns a ResponseEntity object, which is a wrapper for an HTTP response object. 

		---> The ResponseEntity class provides control over things such as HTTP status codes, HTTP headers, and the response body itself. 

		---> This ResponseEntity class is often used in exception handling behavior and in "happy path" situations where the normal 200 response is returned. 


---> An example is given below of how the @ExceptionHandler annotation is used: 


	@ExceptionHandler
	public ResponeEntity<StudentErrorResponse> handleException(StudentNotFoundException exception) {

		StudentErrorResponse error = new StudentErrorResponse(); 

		...Set code, message, other  details...

		return new ResponseEntity<>(error, HttpStatus.Not_Found); 
	}		

	---> The ResponseEntity is parameterized with the custom error response class and accept the class instance and the appropriate status code to return. 

	---> Important: The error code set in the error response object is not the same as the error code that is given to the ResponseEntity class. 

		---> The error code accepted directly by the ResponseEntity class interacts with the system of the client machine to inform it of the status code. 

			---> The "error code" of the custom response object is simply a value that is meant for presentational purposes to inform the end user the of client why the request failed. 

			---> Therefore, these 2 values must be considered as separate in error handling situations. 


         
 