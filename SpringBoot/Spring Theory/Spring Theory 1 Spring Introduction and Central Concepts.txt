Spring Theory: Fundamentals of Spring Revisited. 


Overview of the Spring Framework: 

---> Spring itself represents a framework consisting of various grouped helper classes that help to streamline enterprise Java development. 

---> Spring Core is the underlying foundation of Spring on top of which everything runs.  

---> The core container of Spring consists of the following parts: 

	
	A. Core => This contains the primary means for creating beans via a Bean Factory class.   

	B. Beans => Instances of objects that are created according to the dependency inversion principle that is used by Spring. 

	C. Spring Expression Language

	D. Context => Contains the created beans and holds them in memory.             


---> Spring also supports aspect oriented programming, which is a declarative form of programming that allows for application wide functionalities such as logging and messaging to be used. 

---> Spring also contains a segment of itself devoted to data access in the form of the Spring Data Access Layer. 

	---> This contains functionalities such as helper classes for JDBC and ORM (Hibernate, JPA, etc), which can be used to simplify application interactions with the database.       

	---> Transactions, messaging, and more are also available via the data access layer. 


---> For web applications, Spring MVC is used in order to allow for the development of web related programming. 

	---> This contains things such as servlets, WebSocket, and other features related to the MVC pattern.              


---> Spring also has a test layer built into it that contains support for testing forms such integration tests, mocking, and unit testing. 

      

The Spring Platform and Spring Projects

---> On top of the core container, the data access layer, aspect oriented programming, Spring MVC, and the test layer, Spring also includes Spring Projects. 

---> These are additionally modules that are built on-top (using) the Core Spring Framework. 

	---> Spring Cloud

	---> Spring Data

	---> Spring Security

	---> SPring Batch

	---> Spring Web Services

	---> There are many more after that. 


---> Each of these projects help to direct Spring use towards specific contexts. 

	---> Each of these projects provide frameworks, configurations, and APIs that can be useful for wokring with the project's stated use case.           


 
Central Spring Concept 1: Inversion of Control. 

---> Inversion of Control (IoC) is a general design choice that involves outsourcing the creation and management of objects to something else other than the developer.         

	---> IoC requires a method to implement it as a design decision. 

	---> In Spring, IoC is implemented by outsourcing the object's lifecycle to an object factory that is responsible for creating instances / beans of the object.         


---> Specifically, Spring implements IoC via the Spring Container, which is an object factory that does 2 key functions: 


	1. Create and manage bean / object lifecycles

	2. Inject dependencies into the object via either setter or constructor injection

	---> This object factory therefore removes the necessity of hard coding the creation of objects from the programmer's need and delegates this responsibility to Spring. 
	
	---> The type of object is also chosen by the object factory, given that this is an implementation of a factory (or abstract factory?) design pattern. 


---> The Spring Container requires a configuration file to be setup in order to define the types of beans that exist, bean dependency relationship, and dependency injection possibilities. 

	---> This can be an appConfig file, multiple segregated config files or for SpringBoot, the ServerApplication file. 


---> The mechanism of Spring is defined as follows: 

	1. Configure beans via the configuration file(s). 

	2. Create the Spring Container 

		---> The Spring container is known as the ApplicationContext

		---> This is the ServerApplication file in SpringBoot. 


	3. Retrieve the beans from the Spring Container for use in the application. 



Review of Dependency Injection in Spring: 

---> Spring is a natural example of the dependency inversion principle from SOLID. 

	---> This principle states that the client (ie user) delegates another object the responsibility of providing the dependencies for an object that is going to be instantiated. 

	---> In Spring terms, the Spring container uses an internal object factory to insert dependencies into the bean that is being instantiated. 

	---> The insertion of objects by the object factory is done using dependency injection. 


---> Therefore, the Spring Container (the object factory) creates and manages objects via IoC and injects object dependencies (helper objects) into the object that is going to be instantiated. 

	---> Altogether this creates the dependency inversion principle stated above. 

	---> Depndency injection is specifically the injection of the helper objects into the bean by the Spring Container / object factory. 


---> There are 2 main types of dependency injection: 

	A. Constructor injection => This uses the constructor of a bean to insert the specific dependencies into the bean. 

		---> Constructor injection is likely to be used at the start of a bean's lifecycle because a constructor is only called on object instantiation. 


	B. Setter injection => This uses specific mutator / setter methods to inject a dependencies into the bean.

		---> Setter injection is likely to be used in the intermediate stages of a bean's lifecycle as setter methods can be used at all stages of an object's lifecycle. 

	
---> The main development process for constructor injection is as folows: 


	1. Define the dependency interface and class. 

	2. Create a constructor in the class to allow for constructor injection. 

	3. Configure the dependency injection in the Spring Config file to define the injection process. 


	---> The config file itself can either be in normal Java code or using XML, which is common for legacy Spring configuration processes (this is generally not present in SpringBoot). 

	---> Specific examples of this injection process will be given later.  


---> Underneath the hood, dependency injection works by using the Spring Container to create the object's dependencies before injecting them to the object. 

	---> All of this occurs when the bean is called to be created in a method (in a Java config file) that resembles a getter method, but set specifically for "getting" the bean. 


---> Small note about constructors in Java: 

	---> If no constructor (parameterized or not) is defined in a Java class, then the Java compiler will create a default constructor implicitly, which is equivalent to a no-args constructor. 

	---> This default constructor is not created for the class if a constructor is already defined and therefore must be created explicitly in the class. 

	---> The use of a no-args constructor can be used for creating blank slate objects with null field values, which can be populated with setter method use. 


---> Setter injection is used in a similar sense to constructor injection, except the setter injection requires setter methods to be present in the bean class. 



Theoretical Speculation: Role of the Config Class / File. 

---> A Spring powered application uses the following steps in order to run: 

	A. A Spring context is created and a Spring configuration file is loaded into the Spring Context. 

	B. Beans are created and retrieved from the Spring Container (in the context?) for use in the application. 

	C. Methods and operations can be performed on the bean during the program operation. 

	D. When the program is finished running, the Spring context is closed.  


---> The Spring Container receives the configuration file or the totality of configuration files defined in the project. 

	---> The configuration files contain the definitions of the various ways beans are created, managed, and injected into the system.  

	---> The injection processes for the bean are therefore defined in the configuration file. 

	---> The bean "configuration" (ie bean creation methods) are called by the Spring Container at runtime in a (likely) dynamic fashion when beans are asked for.  

	---> Therefore, external code operates on the methods defined inside of the "configuration" object defined in the config file.  








 