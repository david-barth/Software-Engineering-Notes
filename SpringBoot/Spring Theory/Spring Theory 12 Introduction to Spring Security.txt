Spring Thery 12: Introduction to Spring Security. 


Basic Introduction to Spring Security: 

---> Spring Security deals with the security of applications, especially web applications, provided by Spring.  

---> The main security model for Spring is based on the following: 


	A. Spring Security is implemented by using Servelt filters in the background. 

		---> Servlet filters allow for pre-processing and post-processing web requests (HTTP requests). 

		---> Servlet filters can route web requests based on programmed security logic. 

		---> The majority of Spring Security is based on Servlet filters. 


	B. Spring security uses a declarative and programmatic (imperative) approach to securing an app. 


---> Spring Security servlet filters act as an intermediary layer on top of the resource layer of an application. 

	---> The resource is therefore a protected resource.  

	---> There are two main sub-components to the security layer: 

		A. Application security configuration 

		B. User roles, passwords, etc. 


---> Spring Security filters work according to 3 stages of filtering: 

	A. Protected / non-protected resource ? => This filter checks to see if the resource is proctected or not. 

	B. User authentication filter => This filter checks to see if the user is authenticated yet. 

		---> If not authenticated, then the user is required to perform authentication (e.g. username / password, two-factor, etc). 


	C. User authorization filter => This filter checks if the user is associated to the correct user role in order to access the resource.

	---> Under most conditions, all 3 main stages of filtering must be passed in order for a user to be given access to a protected resource serverside. 

	---> Note: In SQ, the use of web filters is likely based on the same principle of using Servlet filters in order to perform various security procedures. 

	
---> Reminder on basic security terminology: 

	A. Authentication => Check to see if a user id / password combination match with credentials stored in the database or application. 

	B. Authorization => Check to see if a user is associated with a user role that is allowed to access the desired resource. 

	---> Authentication and authorization can be implemented through various approaches: 

		A. In-memory

		B. Database use => This can involve retrievals of various authentication and rights authorizations from the DB. 

			---> A complicated use case involves the RMS from SQ. 

		C. LDAP (Lightweight Directory Access Protocol) => This can be researched more when relevant. 

		D. Other custom approaches



---> On the 2 different approaches to programming security in Spring: 

	A. Declarative security => This uses a configurational approach to defining application security. 

		---> Note: Declarative approaches and configuration are synonomous in such a context because configuration involves "declaring" configurational aspects of something. 

		---> The configurational approach can either be via Java (@Configuration) or via XML configuration. 

		---> This allows for a proper separation between application code and security related code.  


	B. Programmatic Security => This approach involves using an API to extend or customize the existing security framework in Spring to meet specific security / business requirements.   


---> Note: It is important to ensure that the version of Spring Security is compatible with the current version of Spring used. 

	---> The Spring Core framework and the Spring Security framework are not fully synchronized with each other and so it is important to ensure that compatible versions are used. 



An Aside on Spring Customization: 

---> Many processes in Spring, such as the Spring MVC based processes, can be customized in different ways. 

---> Some examples can be seen in the Corrado mentorship videos, but an example is also provided in Spring MVC configuration: 


	---> AbstractAnnotationConfigDispatcherServletInitializer => This abstract base class can be extended, with the proper method overridden as needed. 

	---> This class in particular specifies servlet mappings and the location fo the app config. 

	---> More importantly, this class is an example of a common pattern wherein different classes or interfaces can be extended or implemented in Spring in order to override default processes in Spring. 

	---> This can apply to other classes such as interceptor classes. 



Basic Security: Username / Password Combinations + User Roles. 

---> Spring Security filters are registered through the AbstractSecurityWebApplicationInitializer abstract class. 

	---> Like with the dispatcher servlet initializer, this class can be extended in order to provide custom configuration properties to its relevant part of the Spring Framework, which in this case is Spring Security. 

	---> This class is necessary for the configuration of the Spring security filters. 

	---> All that it necessary is to extend this base abstract class with no need to override any methods. 


---> In order to configure Spring Security, the following config file must be used: 

	@Configuration
	@EnableWebSecurity
	public class DemoSecurityConfig extends WebSecurityConfigurerAdapter {

		@Override 
		protected void configure(AuthenticationManagerBuilder auth) throws Exception {
			
			UserBuilder users = User.withDefaultPasswordEncoder(); 
			
			auth.inMemoryAuthentication()
				.withUSer(users.username("John").password("SomePW").roles("Admin"));
		}
	}        

	---> As with all config files, @Configuration needs to be used in order to specify this as a config file. 

	---> @EnableWebSecurity is the annotation used to allow Spring Core to recognize beans that are associated with Spring Security. 

		---> It is a pattern in Spring config files, with other components of the Spring ecosystem, to use an annotation of the nomenclature @EnableSomething in order to recognize beans that are associated with that cpart of Spring. 

		---> E.g. This also applies to Spring MVC and other more niche parts of Spring. 


	---> The above configure() method configures an in-memory authentication approach. 

		---> Compared to more rigorous approaches, this is likely no a best practice. 

		---> Note: The roles() method can accept anything as a role, but best practice likely uses an enum for a defined set of roles. 


	---> Within the WebSecurityConfigurerAdapter base class there are different overloaded configure() methods that can be used for different security configurations, including HTTP based security and web security. 


	---> Also note: withDefaultPasswordEncoder() is considered deprecated. 	


---> Use case for in-memory authentication: 

	---> In-memory authentication is not a recommended best practice for security purposes.  

	---> Instead, it is best used for tutorial and learning purposes. 

	---> Best practice => Use a persistent form of authentication that involves database retrievals. 

	---> Practical usage for in-memory use cases usually involve some form of caching, such as an embedded / in-memory database (e.g. Redis, H2) or other caching forms used to optimize performance. 



---> The following shows an example of setting up HTTP security in Spring Security: 

	---> This involves using configure() for a class called HttpSecurity, which is responsible for configuring security for resource endpoints. 

		---> configure(AuthenticationManagerBuilder) is used for configuring users via in-memory, LDAP, and database approaches. 

		---> Each of the overloaded configure() methods is responsible for a different aspect of security. 


	@Configuration
	@EnableWebSecurity
	public class DemoSecurityConfig extends WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			
			http.authorizeRequests()
				.anyRequest().authenticated()
				.and()
				.formLogin()
				.loginPage("/showMyLoginPage")
				.loginProcessingUrl("/authenticateTheUser")
				.permitAll();
		}
	}
	

	---> The above overrided method shows how to configure a login form requirement for all in-bound HTTP requests to the server side. 

	---> The following is the breakdown for the method chain:

		A. authorizeRequests() => This restricts access based on the HttpServletRequest type object.

		B. anyRequest().authenticated() => This portion specifies that all in-bound requests must be authenticated / logged in to proceed further. 

		C. and().formLogin().loginPage().loginProcessingURL() => This specifies that a custom login form and process is being used. 

			---> loginPage() refers to the endpoint that is used to access the login page resource. 

			---> loginProcessingUrl() refers to the endpoint used to process login details in order to complete the actual authentication process. 


		D. permitAll() => This method allows all users to see the login page. 


	---> A controller does need to be implemented for this however, with @GetMapping used to specify the endpoint. 


---> Important => The overall login process mechanism boils down to this: 

	1. A user sends an HTTP request for a resource towards a resource endpoint. 

	2. The Spring filter servlet intercepts the incoming request for security purposes. 

	3. The servlet redirects the user to a login page / authentication portion of the app. 

	4. The user provides credentials for the authentication and sends these details to a specific endpoint for authentication processing. 

	5. Two things can happen based on the outcome of the authentication processing: 

		A. Successful outcome => The user's request is let through to the protected endpoint and ethe desired resource is returned, producing a redirect to the desired resource (and its corresponding UI). 

		B. Unsuccessful outcome => The user's request is blocked and the user is redirected back to the login page for a further attempt. 

			---> In this case, there is also an error message that comes with this to inform the user that the authentication failed. 



Focusing on the Logout Process: 

---> In between successful authentication and logout, the following ends up occurring: 

	1. A new HTTP session object is created upon login, which is used clientside as a way to represent a user's interaction with protected endpoint content. 

	2. The session also contains a signature / flag that is used to show that successful login has occurred (this can be contained on a cookie). 

		---> Such signatures are created by session cookies which are attached to an HTTP session.
 

	3. Upon triggering the logout process, the session object is destroyed and this necessitates the need for a new authentication process. 


---> In the HttpSecurity base configure method for Spring Security configuration the basic functionality for a logout is as follows: 


	@Override 
	protected void configure(HttpSecurity http) throws Exception {

		http.authorizeRequests()
			.anyRequest().authenticated()
			.and()
			.formLogin()
			.loginPage("/customPage")
			.loginProcessingUrl("authenticateTheUser")
			.permitAll()
			.and()
			.logout()
			.permitAll();
	}

	---> logout() sends data to a default logout URL in order to initiate the logout process. 

	---> The default logout URL will trigger the invalidation and potential destruction of the session cookies and the HTTP session itself (assuming non-persistent sessions).  

	---> After the invalidation of cookies and session, the user is redirected to the logout page and the response from the logout endpoint includes a "logout" parameter to indicate the change to a logged out state.  

		---> Logging out is a POST request and not a GET request, likely because an HTTP body is needed to contain information to logout the correct user. 




Cross-site Request Forgery: 

---> CSRF is a security attack in which a website tricks a user into executing an action on a web app that the user is currently logged into. 

---> In order to protect against CSRF attacks, it is necessary to embed additional authentication data / a token into HTML forms. 

	---> The token needs to be verified before the form is submitted or processed on the backend. 


---> Spring Security CSRF protection is handled through Spring Security filters. 

---> To implement CSRF protection, the synchronizer token pattern is used: 

	A. A request includes a session cookie and a randomly generated token. 

	B. Before a request is processed at its relevant endpoint, the token must be verified by the Spring Security filters. 


---> CSRF protection is enabled by default for an application (if using <form:form>) and is recommended for use for normal web browser web requests. 

	---> But for non-browser clients, CSRF can be disabled in some carefully considered cases. 

	---> Note: CSRF must be included in form submission via a POST request in order to be used in the application. 


---> Note: It is also possible to manually add the CSRF token without <form:form> (JSP form tag), but this will not be covered here. 



Restricting Access based on User Role: 

---> It is possible to restrict user access to endpoints to certain user roles.  

---> This is possible through the HttpSecurity based configure() method in the Spring Security configuration file: 



	@Override 
	protected void configure(HttpSecurity http) throws Exception {

		http.authorizeRequests()
			.antMatchers("/").hasRole("Role1")
			.antMatchers(".leaders/**").hasRole("Role2")
			.and()
			.formLogin()
			.loginPage("/customPage")
			.loginProcessingUrl("authenticateTheUser")
			.permitAll()
			.and()
			.logout()
			.permitAll();
	}

	---> The anyRequest().authenticated() line is replaced with lines of the form: antMatchers().hasRole(). 

		---> antMatchers() => This is a SpringBoot HTTP method that is used to match onto a specific URL or URL pattern and only permit requests based on that match to be accepted. 

		---> hasRole() => This is another filter that applies on top of the antMatchers() filter in order to further filter URLs based on the user role of the client that submitted the request. 

		---> These are both examples of "filters", which are used to filter HTTP requests. 


	---> Sections of the method chain act as filters to all possible HTTP requests that enter the chain.

	---> Important reminder: The following represents the chain of events that likely occurs when the antMatchers() filter code is integrated into the application for protecting an endpoint based on user role: 

		1. A user attempts to click a UI element that triggers a request to the backend for a particular resource at a particular endpoint (e.g. via form submission + link). 

		2. The request is intercepted first by the Spring Security layer.

		3. The request goes through a method chain of classes configured by methods relating to different parts of the HttpSecurity instance in the related config file. 

		4. The request will go through various filters including matchers (user role / authorization) or authentication based filters. 

		5. Based on the nature of the submitted request and its interaction with the filters, one of the following will happen: 

			A. The filters block the request and filter it out, returning a 403 unauthorized or similar code.  This occurs if the request doesn't have the appropriate authentication or authorization details. 

				---> The filters will pass the request to a supporting controller in order to handle the issue of failed authentication or unauthorized access. 
				
				---> This controller code can be customized in a granular fashion in the controller class.  


			B. The request passes through the filters and continues forward to the protected endpoint, allowing the resource to be retrieved. 


		---> and() => This represents a way to chain together the methods of different Configurer classes together.  

			---> Each of these sections between and() act to configure different classes in the Spring Security filters, which are all triggered during different contexts for HTTP transactions. 

				---> Portions of filters are triggered during authentication (e.g. formLogin() or logout()) or authorization (antMatcher().hasRole()) based HTTP transactions. 





			---> Therefore, the above code DOES NOT represent a sequential series of events with respect to one HTTP transaction. 
	
					
---> The above sequence of events refers to securing resource endpoints in their entirety based on authorization. 

	---> It is also possible to secure pieces of UI based on user role as well, but this can vary depending on the approach to UI adopted for the application. 

	---> In template engine + serverside view rendering based applications, individual UI can be restricted by access role via certain tags (e.g. in JSP) that programmatically restrict access based on user role. 

	---> In client side rendering (e.g. Angular, React, Vue), a different mechanism is in place, likely via the use of some form of conditional rendering based on user role header indications or some sort of signature (e.g. tokens / cookies). 

		---> In larger enterprise settings, the authentication + authorization programming is taken care of in different parts of the architecture. 

		---> Lower level "plugins" are integrated into the overall scaffolding allowing for a separation of concerns with respect to that particular artifact. 

		---> In this sense, UI authorization based rendering is minimized in most cases.  


	---> Overall, the approach depends on the context. 



Database based Authentication + Authorization Approaches: 

---> Database retrieval of user account rights and credentials is a far more common method of approaching authentication than in-memory. 

---> This approach can be implemented in Spring Security with predefined table schemas that can be modified. 

	---> There is still a need to write the application code that will handle the queries, which is handled by JDBC and Hibernate. 


---> The default Spring Security database schema is based as follows: 

	Table A => users:

		---> username
		---> password
		---> enabled

		---> enabled => This column determines if a user can log in or not. 


	Table B => authorities:

		---> username
		---> authority


	---> The authorities table corresponds to user roles. 

		---> Authorities / user roles must be unique constraints that consist of a combination of the username / authority column. 

		---> The username column in authorities ends up being the foreign key that connects the two above tables.

		---> Spring Security uses the prefix format of "ROLE_SomeRole" in order to define a user role in the authorities table. 


	---> Note the column and table names must be the same as defined here in order for the default Spring Security configuration to work. 




---> It is necessary to run an init SQL script in order to setup the underlying tables for Spring Security to use. 


---> Note: Passwords are stored in a specific format: {id}encodedPassword

	---> The encoded password is the password that is either encoded as an encrypted form or as plain text. 

	---> The {id} refers to the encoding / encryption algorithm that is used to convert the password from plain text into a hashed form. 

		---> Options include "noop" for plain text, bcrypt, and more. 

		---> Encrypted forms are usually hashed passwords. 

		---> An example:  "{noop}test123" or "{bcrypt}test123"

			---> {bcrypt} is an id string that will tell the underlying Spring Security code to use the bcrypt hashing algorithm. 



---> A note on configuration: In non-springboot based configurations, the JDBC connection must be configured using either yaml or properties files. 

	---> An example is shown: 

	@Configuration
	@EnableWebMvc
	@ComponentScan
	@PropertySource("persistence-mysql.properties")
	public class DemoAppConfig {


		@Autowired
		private Environment env; 

		@Bean
		public DataSoruce securityDataSource() {

			//Create connection pool: 
			ComboPooledDataSource securityDataSource = new ComboPooledDataSource(); 

			//Setup jdbc driver: 
			try {
				securityDataSource.setDriverClass(env.getProperty("jdbc.driver"));
			} catch (PropertyVetoException exc) {

				throw new RuntimeException(exc); 
			}

			//Other setter methods for connection properties (JDBC url, user + password for DB access) and connection pool properties (min + max pool sizes, etc)
		}
		
	}

	---> During the build process, files within the src/main/resources folder are automatically copied to the classpath at build time. 

	---> The @PropertySource annotation tells the compiler to read the specified file on the classpath and inject the property values into their relevant beans during dependency injection and setup. 

	---> Reminder: Properties files and yaml files are used to hold environmental variables, which in enterprise settings are not hard coded as a best practice. 

		---> Spring has an Environment class that reads and holds the data from the properties / yaml files for use in the configuration of beans. 

	
	---> A DataSource class indicates a different data source / database that the application interacts with: 

		---> Note that the data source itself is not just the database, but an abstraction that includes constructs such as the database + the connection pool. 

		---> The DataSource class minimally requires the database connection props and ideally the connection pool props (for best practice + performance optimization). 


---> Within the configure() method of the WebSecurityConfigurerAdapter subclass, it is necessary to do the following to enable JDBC authentication: 


	@Configuration
	@EnableWebSecurity
	public class DemoSecurityConfig extends WebSecurityConfigurerAdapter {

		@Autowired
		private DataSource securityDataSource; 

		@Override 
		protected void configure(AuthenticationManagerBuilder auth) throws Exception {

			auth.jdbcAuthentication().dataSource(securityDataSource);
		}
	}


	---> The configured data source acts as a dependency to the security configuration class. 

	---> Note: configure() handles the configuration of different security configuration objects: 


		A. HttpSecurity => The configuration of this object acts as a class that configures a set of class instances relating to security (authentication + authorization) from the HTTP transaction perspective. 

		B. AuthenticationManagerBuilder => The configuration of this object configures the authentication approach that is used by the app.

			---> This builder can help to create the families of class instances needed for various authentication approaches such as JDBC authentication, LDAP, in-memory and more. 

			---> In the JDBC authentication approach, the security data source is given here. 


	---> Users don't need to be hard coded and if the predefined schema is followed, then it is possible for retrievals of users and rights to be automated.  
			
		---> If other schemas are used, then manual coding of the appropriate DAO based accesses would need to occur with the appropriate entity model. 


Password Encryption in Spring Security: 

---> It is not a best practice to store passwords as plain text in a database. 

	---> Hashing based encryption or some other encryption method is desirable for production level security standards. 


---> A recommended form of encryption is the bcrypt algorithm: 

	---> bcrypt is a one-way hashing encryption algorithm that also adds a randomly generated portion of characters to the end of the hashed password called a "salt" for additional protection.

	---> This and other mechanisms included in bcrypt help to provide defense against bruteforce attacks. 


---> The Spring security filter relating to JDBC authentication use the following rough rpocess in order to perform the password based authentication: 

	A. The password for the user is retrieved from the DB.

	B. The encoding algorithm ID ({bcrypt} in this case) is read.

	C. The salt is taken from the DB password and appended to a hashed version of the password from the form submitted password. 

	D. The encrypted form password is compared with the DB stored password. 

	E. Two things can happen depending on the results of that comparison: 

		A. If a match occurs, a successful authentication occurs. 

		B. If a match doesn't occur, then authentication fails. 


	F. Depending on the results of the match comparison, the classes relating to the HttpSecurity object will then either redirect the user to the desired endpoint or the user will be redirected to try authenticating again (or blocked). 

	---> Note: The DB password is never decrypted since bcrypt is a one-way encryption algorithm. 






