Spring Thery 12: Introduction to Spring Security. 


Basic Introduction to Spring Security: 

---> Spring Security deals with the security of applications, especially web applications, provided by Spring.  

---> The main security model for Spring is based on the following: 


	A. Spring Security is implemented by using Servelt filters in the background. 

		---> Servlet filters allow for pre-processing and post-processing web requests (HTTP requests). 

		---> Servlet filters can route web requests based on programmed security logic. 

		---> The majority of Spring Security is based on Servlet filters. 


	B. Spring security uses a declarative and programmatic (imperative) approach to securing an app. 


---> Spring Security servlet filters act as an intermediary layer on top of the resource layer of an application. 

	---> The resource is therefore a protected resource.  

	---> There are two main sub-components to the security layer: 

		A. Application security configuration 

		B. User roles, passwords, etc. 


---> Spring Security filters work according to 3 stages of filtering: 

	A. Protected / non-protected resource ? => This filter checks to see if the resource is proctected or not. 

	B. User authentication filter => This filter checks to see if the user is authenticated yet. 

		---> If not authenticated, then the user is required to perform authentication (e.g. username / password, two-factor, etc). 


	C. User authorization filter => This filter checks if the user is associated to the correct user role in order to access the resource.

	---> Under most conditions, all 3 main stages of filtering must be passed in order for a user to be given access to a protected resource serverside. 

	---> Note: In SQ, the use of web filters is likely based on the same principle of using Servlet filters in order to perform various security procedures. 

	
---> Reminder on basic security terminology: 

	A. Authentication => Check to see if a user id / password combination match with credentials stored in the database or application. 

	B. Authorization => Check to see if a user is associated with a user role that is allowed to access the desired resource. 

	---> Authentication and authorization can be implemented through various approaches: 

		A. In-memory

		B. Database use => This can involve retrievals of various authentication and rights authorizations from the DB. 

			---> A complicated use case involves the RMS from SQ. 

		C. LDAP (Lightweight Directory Access Protocol) => This can be researched more when relevant. 

		D. Other custom approaches



---> On the 2 different approaches to programming security in Spring: 

	A. Declarative security => This uses a configurational approach to defining application security. 

		---> Note: Declarative approaches and configuration are synonomous in such a context because configuration involves "declaring" configurational aspects of something. 

		---> The configurational approach can either be via Java (@Configuration) or via XML configuration. 

		---> This allows for a proper separation between application code and security related code.  


	B. Programmatic Security => This approach involves using an API to extend or customize the existing security framework in Spring to meet specific security / business requirements.   


---> Note: It is important to ensure that the version of Spring Security is compatible with the current version of Spring used. 

	---> The Spring Core framework and the Spring Security framework are not fully synchronized with each other and so it is important to ensure that compatible versions are used. 



An Aside on Spring Customization: 

---> Many processes in Spring, such as the Spring MVC based processes, can be customized in different ways. 

---> Some examples can be seen in the Corrado mentorship videos, but an example is also provided in Spring MVC configuration: 


	---> AbstractAnnotationConfigDispatcherServletInitializer => This abstract base class can be extended, with the proper method overridden as needed. 

	---> This class in particular specifies servlet mappings and the location fo the app config. 

	---> More importantly, this class is an example of a common pattern wherein different classes or interfaces can be extended or implemented in Spring in order to override default processes in Spring. 

	---> This can apply to other classes such as interceptor classes. 



Basic Security: Username / Password Combinations + User Roles. 

---> Spring Security filters are registered through the AbstractSecurityWebApplicationInitializer abstract class. 

	---> Like with the dispatcher servlet initializer, this class can be extended in order to provide custom configuration properties to its relevant part of the Spring Framework, which in this case is Spring Security. 

	---> This class is necessary for the configuration of the Spring security filters. 

	---> All that it necessary is to extend this base abstract class with no need to override any methods. 


---> In order to configure Spring Security, the following config file must be used: 

	@Configuration
	@EnableWebSecurity
	public class DemoSecurityConfig extends WebSecurityConfigurerAdapter {

		@Override 
		protected void configure(AuthenticationManagerBuilder auth) throws Exception {
			
			UserBuilder users = User.withDefaultPasswordEncoder(); 
			
			auth.inMemoryAuthentication()
				.withUSer(users.username("John").password("SomePW").roles("Admin"));
		}
	}        

	---> As with all config files, @Configuration needs to be used in order to specify this as a config file. 

	---> @EnableWebSecurity is the annotation used to allow Spring Core to recognize beans that are associated with Spring Security. 

		---> It is a pattern in Spring config files, with other components of the Spring ecosystem, to use an annotation of the nomenclature @EnableSomething in order to recognize beans that are associated with that cpart of Spring. 

		---> E.g. This also applies to Spring MVC and other more niche parts of Spring. 


	---> The above configure() method configures an in-memory authentication approach. 

		---> Compared to more rigorous approaches, this is likely no a best practice. 

		---> Note: The roles() method can accept anything as a role, but best practice likely uses an enum for a defined set of roles. 


	---> Within the WebSecurityConfigurerAdapter base class there are different overloaded configure() methods that can be used for different security configurations, including HTTP based security and web security. 


	---> Also note: withDefaultPasswordEncoder() is considered deprecated. 	


---> Use case for in-memory authentication: 

	---> In-memory authentication is not a recommended best practice for security purposes.  

	---> Instead, it is best used for tutorial and learning purposes. 

	---> Best practice => Use a persistent form of authentication that involves database retrievals. 

	---> Practical usage for in-memory use cases usually involve some form of caching, such as an embedded / in-memory database (e.g. Redis, H2) or other caching forms used to optimize performance. 



---> The following shows an example of setting up HTTP security in Spring Security: 

	---> This involves using configure() for a class called HttpSecurity, which is responsible for configuring security for resource endpoints. 

		---> configure(AuthenticationManagerBuilder) is used for configuring users via in-memory, LDAP, and database approaches. 

		---> Each of the overloaded configure() methods is responsible for a different aspect of security. 


	@Configuration
	@EnableWebSecurity
	public class DemoSecurityConfig extends WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			
			http.authorizeRequests()
				.anyRequest().authenticated()
				.and()
				.formLogin()
				.loginPage("/showMyLoginPage")
				.loginProcessingUrl("/authenticateTheUser")
				.permitAll();
		}
	}
	

	---> The above overrided method shows how to configure a login form requirement for all in-bound HTTP requests to the server side. 

	---> The following is the breakdown for the method chain:

		A. authorizeRequests() => This restricts access based on the HttpServletRequest type object.

		B. anyRequest().authenticated() => This portion specifies that all in-bound requests must be authenticated / logged in to proceed further. 

		C. and().formLogin().loginPage().loginProcessingURL() => This specifies that a custom login form and process is being used. 

			---> loginPage() refers to the endpoint that is used to access the login page resource. 

			---> loginProcessingUrl() refers to the endpoint used to process login details in order to complete the actual authentication process. 


		D. permitAll() => This method allows all users to see the login page. 


	---> A controller does need to be implemented for this however, with @GetMapping used to specify the endpoint. 


---> Important => The overall login process mechanism boils down to this: 

	1. A user sends an HTTP request for a resource towards a resource endpoint. 

	2. The Spring filter servlet intercepts the incoming request for security purposes. 

	3. The servlet redirects the user to a login page / authentication portion of the app. 

	4. The user provides credentials for the authentication and sends these details to a specific endpoint for authentication processing. 

	5. Two things can happen based on the outcome of the authentication processing: 

		A. Successful outcome => The user's request is let through to the protected endpoint and ethe desired resource is returned, producing a redirect to the desired resource (and its corresponding UI). 

		B. Unsuccessful outcome => The user's request is blocked and the user is redirected back to the login page for a further attempt. 

			---> In this case, there is also an error message that comes with this to inform the user that the authentication failed. 



Focusing on the Logout Process: 

---> In between successful authentication and logout, the following ends up occurring: 

	1. A new HTTP session object is created upon login, which is used clientside as a way to represent a user's interaction with protected endpoint content. 

	2. The session also contains a signature / flag that is used to show that successful login has occurred (this can be contained on a cookie). 

		---> Such signatures are created by session cookies which are attached to an HTTP session.
 

	3. Upon triggering the logout process, the session object is destroyed and this necessitates the need for a new authentication process. 


---> In the HttpSecurity base configure method for Spring Security configuration the basic functionality for a logout is as follows: 


	@Override 
	protected void configure(HttpSecurity http) throws Exception {

		http.authorizeRequests()
			.anyRequest().authenticated()
			.and()
			.formLogin()
			.loginPage("/customPage")
			.loginProcessingUrl("authenticateTheUser")
			.permitAll()
			.and()
			.logout()
			.permitAll();
	}

	---> logout() sends data to a default logout URL in order to initiate the logout process. 

	---> The default logout URL will trigger the invalidation and potential destruction of the session cookies and the HTTP session itself (assuming non-persistent sessions).  

	---> After the invalidation of cookies and session, the user is redirected to the logout page and the response from the logout endpoint includes a "logout" parameter to indicate the change to a logged out state.  

		---> Logging out is a POST request and not a GET request, likely because an HTTP body is needed to contain information to logout the correct user. 




Cross-site Request Forgery: 

---> CSRF is a security attack in which a website tricks a user into executing an action on a web app that the user is currently logged into. 

---> In order to protect against CSRF attacks, it is necessary to embed additional authentication data / a token into HTML forms. 

	---> The token needs to be verified before the form is submitted or processed on the backend. 


---> Spring Security CSRF protection is handled through Spring Security filters. 

---> To implement CSRF protection, the synchronizer token pattern is used: 

	A. A request includes a session cookie and a randomly generated token. 

	B. Before a request is processed at its relevant endpoint, the token must be verified by the Spring Security filters. 


---> CSRF protection is enabled by default for an application (if using <form:form>) and is recommended for use for normal web browser web requests. 

	---> But for non-browser clients, CSRF can be disabled in some carefully considered cases. 

	---> Note: CSRF must be included in form submission via a POST request in order to be used in the application. 


---> Note: It is also possible to manually add the CSRF token without <form:form> (JSP form tag), but this will not be covered here. 



Restricting Access based on User Role: 

---> It is possible to restrict user access to endpoints to certain user roles.  

---> This is possible through the HttpSecurity based configure() method in the Spring Security configuration file: 



	@Override 
	protected void configure(HttpSecurity http) throws Exception {

		http.authorizeRequests()
			.antMatchers("/").hasRole("Role1")
			.antMatchers(".leaders/**").hasRole("Role2")
			.and()
			.formLogin()
			.loginPage("/customPage")
			.loginProcessingUrl("authenticateTheUser")
			.permitAll()
			.and()
			.logout()
			.permitAll();
	}

	---> The anyRequest().authenticated() line is replaced with lines of the form: antMatchers().hasRole(). 

		---> antMatchers() => This is a SpringBoot HTTP method that is used to match onto a specific URL or URL pattern and only permit requests based on that match to be accepted. 

		---> hasRole() => This is another filter that applies on top of the antMatchers() filter in order to further filter URLs based on the user role of the client that submitted the request. 

		---> These are both examples of "filters", which are used to filter HTTP requests. 


	---> Sections of the method chain act as filters to all possible HTTP requests that enter the chain.

	---> Important reminder: The following represents the chain of events that likely occurs when the antMatchers() filter code is integrated into the application for protecting an endpoint based on user role: 

		1. A user attempts to click a UI element that triggers a request to the backend for a particular resource at a particular endpoint (e.g. via form submission + link). 

		2. The request is intercepted first by the Spring Security layer.

		3. The request goes through a method chain of classes configured by methods relating to different parts of the HttpSecurity instance in the related config file. 

		4. The request will go through various filters including matchers (user role / authorization) or authentication based filters. 

		5. Based on the nature of the submitted request and its interaction with the filters, one of the following will happen: 

			A. The filters block the request and filter it out, returning a 403 unauthorized or similar code.  This occurs if the request doesn't have the appropriate authentication or authorization details. 

				---> The filters will pass the request to a supporting controller in order to handle the issue of failed authentication or unauthorized access. 
				
				---> This controller code can be customized in a granular fashion in the controller class.  


			B. The request passes through the filters and continues forward to the protected endpoint, allowing the resource to be retrieved. 


		---> and() => This represents a way to chain together the methods of different Configurer classes together.  

			---> Each of these sections between and() act to configure different classes in the Spring Security filters, which are all triggered during different contexts for HTTP transactions. 

				---> Portions of filters are triggered during authentication (e.g. formLogin() or logout()) or authorization (antMatcher().hasRole()) based HTTP transactions. 





			---> Therefore, the above code DOES NOT represent a sequential series of events with respect to one HTTP transaction. 
	
					
---> The above sequence of events refers to securing resource endpoints in their entirety based on authorization. 

	---> It is also possible to secure pieces of UI based on user role as well, but this can vary depending on the approach to UI adopted for the application. 

	---> In template engine + serverside view rendering based applications, individual UI can be restricted by access role via certain tags (e.g. in JSP) that programmatically restrict access based on user role. 

	---> In client side rendering (e.g. Angular, React, Vue), a different mechanism is in place, likely via the use of some form of conditional rendering based on user role header indications or some sort of signature (e.g. tokens / cookies). 

		---> In larger enterprise settings, the authentication + authorization programming is taken care of in different parts of the architecture. 

		---> Lower level "plugins" are integrated into the overall scaffolding allowing for a separation of concerns with respect to that particular artifact. 

		---> In this sense, UI authorization based rendering is minimized in most cases.  


	---> Overall, the approach depends on the context. 



Database based Authentication + Authorization Approaches: 

---> 
