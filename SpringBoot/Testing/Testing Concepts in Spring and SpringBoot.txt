Testing For Spring + SpringBoot. 


---> Unit testing is the first level of testing that occurs when trying to ensure quality code, either in production in a CI / CD pipeline. 

---> Inside of a SpringBoot project, unit tests are automatically run when triggering the build process via Maven or Gradle.  

---> It is normal in such projects to keep tests separated inside of a separate testing package whose structure resembles the package structure of the actual project.  

---> Important: Unit testing reflects the use of tests to test small "units" of code.  

	---> The focus is to test the smallest functioning pieces of code in an application to ensure that they produce the expected outputs for a given set of test cases. 

	---> In practice it is a good idea to aim for 80+% test coverage of application code with tests that cover useful cases in an application. 


---> This will also cover more advanced testing such as integration testing and smoke testing. 

	---> Important => JUnit can be used for unit testing, integration testing, and more complex testing. 

		---> It just simply depends on how the tests are composed based on the flavor / approach used in the individual test. 

		---> Some of these flavors are covered below. 




Good Principles for Unit Testing: 


1. Prefer simple test cases => Simple hard coded test cases can be valuable to have over production logic based values. 

	---> Production logic should be minimized in such cases. 

	---> But there are limits to hard coding in cases involving magic number. 


2. Using appropriate assertions => Distinct assertions should be used in order to test different aspects of a function output. 

	---> E.g. Assert.assertEquals and Assert.assertNotEquals can be used 

	---> E.g. AssertNotNull, AssertNotSame can also be used


3. Keeping test Scenarios Separate => Asserts should be geared towards one test case and not cover multiple test cases. 

	---> E.g. Testing for a null value and testing for a present value in 2 separate tests. 


4. Aiming to test production scenarios => Real Scenarios that could occur in production are more worth testing than trivial scenarios. 

	---> Some ideas: 

		A. Data not found scenarios 

		B. Abnormal objecs 

		(Needs more research) 

5. External services should be mocked => In testing some more complex classes / objects, which rely on external services, it is helpful to mock these external services on a logical level. 

	---> E.g. A Service class that depends on a Repository class. 

		---> The repository class is mocked on a logical level by having specific outputs be returned upon execution of a "method". 

		---> This can be done via a library such as Mockito, which can create mock objects for such purposes. 


6. Using testing lirbary annotations => @BeforeEach, @BeforeAll, etc can be used to create data and arrange objects before the execution of tests in order to improve performance and keep test cases separated from each other. 



Unit testing flavor 1: Using complete mock data + objects. 

---> In this flavor, a test is written in such a way that mock data and objects are used in order to perform the unit tests. 

---> For example, a test Repository class can be a dependency of a Service class being tested. 

	---> It can be expensive to start the Spring context for everytime a test class is run.  

	---> Instead, it could be sufficient to mock the behavior of the Repository dependency by creating a mock object that simulates the expected outcomes of the actual mock repository. 


---> The main concept is as follows: 

	@ExtendWith(MockitoExtension.class)                         
	class ServiceTest {

    	@Mock
    	Database databaseMock;                                  

    	@Test
    	public void testQuery()  {
 	      		assertNotNull(databaseMock);
        		when(databaseMock.isAvailable()).thenReturn(true);  
        		Service t  = new Service(databaseMock);             
        		boolean check = t.query("* from t");                
        		assertTrue(check);
    		}
	}  

	---> As seen above, the databaseMock is a mock object created via the use of the @Mock annotation in Mockito. 

		---> @Mock likely receives the type Database as a blueprint for use in creating a proxy Database object that has the necessary methods needed for assigning invoking behavior to upon being called. 

		---> This is a likely use of the proxy design pattern. 		


	---> Mockito then uses a series of methods: when() and thenReturn(), to define the behavior that a method is supposed to adopt upon invocation. 

		---> In this case, when isAvailable() is called, then  the value of true is returned from the mock object method. 

		---> This behavior is therefore mocking only the intended output of the isAvailable() method. 


	---> It is assumed that isAvailable() is called in the query() method at some point, which triggers the invocation behavior defined above. 

	---> Overall, the true source code of the dependency is not being tested, but merely its known behavior is being replicated. 

		---> The basis of this mocking approach allows for a less expensive testing process, with realistic results. 

		---> However, this still does not fully test out production scenarios or leverages Springboot's full capabilities for testing. 

			---> This flavor will be explored next. 


---> Important note: It is best practice to mock objects that are created in the application source code by the developer and not already from well verified 3rd party libraries. 

	---> Practical example: Mocking an EntityManager class is not a particularly effective approach as it is already a well used and documented class. 

		---> Therefore, creating tests for the repository level is not altogether important. 

		---> Instead, it can be recommended to mock the Repository level when testing the Service level. 

		---> This allows for a proper testing of custom code. 

 


 

Unit Testing Flavor 2: Using the Spring Context to Test Objects. 

---> This can apply for Spring beans such as Services, Repositories, and even Controllers potentially. 

---> This approach becomes less of "unit testing" and closer to integration testing, which focuses on testing combinations of classes that work together.  

	---> E.g. Testing a service through initializing the Spring context and having an actual repository class that can potentially fetch the required objects from the database. 

	---> By comparison a unit test for such a service would involve using the mock testing approach. 

	---> This form of "integration test" is resistent against internal refactorings of individual classes, which a mock based unit testing approach can break against in some cases. 

		---> The reason this is considered an integration test is because different components: a database, a service class, and a repository are involved in composing the test. 

		---> Therefore, the test is based on integrating the components together in order to test a flow between the components. 

		---> Official => The integration test is defined as a test that uses 2 or more REAL parts to test code and not mock objects with prepared behaviors. 

			---> This is also called testing a slice of Spring context, as a portion of the spring application is being test. 






---> This approach involves using the Spring context in order to create the integration tests. 

---> A simple example of a smoke test is shown as follows with using the Spring context for testing: 

	@SpringBootTest
	public class SmokeTest {

		@Autowired
		private HomeController controller;

		@Test
		public void contextLoads() throws Exception {
			assertThat(controller).isNotNull();
		}
	}

	---> @SpringBootTest is an annotation that can be used for looking for a main configuration class (e.g. one with @SpringBootApplication for SpringBoot applications). 

		---> This annotation will start a Spring context. 

	
	---> The purpose of the smoke test is simply a test that is used to test for simple, but fundamental and severe failure possibilities. 

		---> These are aimed at addressing questions such as "Does the program run?" and other basic fundamental situations needed for the application to function properly. 

		---> In this case, the smoke test is referring to whether a controller is created or not.  


	---> Since a Spring context is started, that means autowiring is present in order to inject the tested class into the testing class. 

	---> More specific version of @SpringBootTest include the following annotations, which are designed for testing different layers of the application: 

		A. @WebMvcTest => To effectively test your web-layer with MockMvc
		
		B. @DataJpaTest => To effectively test your persistence layer

		C. @JsonTest => To verify JSON serialization and deserialization
		
		D. @RestClientTest => To test the RestTemplate.



Links to good articles on best practices: 

	1. https://phauer.com/2019/modern-best-practices-testing-java/

		---> A comprehensive guide to best practice testing concepts for testing in Java. 

		---> Covers both backend integration tests and unit tests. 


	2. https://spring.io/guides/gs/testing-web/

		---> Introduction into some aspects of Spring Context based integration testing. 


	3. https://www.vogella.com/tutorials/Mockito/article.html

		---> A good overview of the different Mockito approaches available. 

